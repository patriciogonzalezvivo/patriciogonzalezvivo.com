!function(){"use strict";function n(n,e){return new THREE.ShaderMaterial({uniforms:void 0===e?{}:e,vertexShader:"varying vec2 v_texcoord;\n    void main() {\n        v_texcoord = uv;\n        gl_Position = vec4(position, 1.0);\n    }",fragmentShader:n})}var e=Math.floor;const i=(0,Math.pow)(2,-32),t=32557,r=19605,o=new Uint16Array(4),a=new DataView(o.buffer),s=(n,e=0)=>{const i=16,t=65535,r=255;for(var o,a=1540483477,s=n.length,c=e^s,f=0;4<=s;)o=((o=n[f]&r|(n[++f]&r)<<8|(n[++f]&r)<<16|(n[++f]&r)<<24)&t)*a+(((o>>>i)*a&t)<<i),c=(c&t)*a+(((c>>>i)*a&t)<<i)^(o=((o^=o>>>24)&t)*a+(((o>>>i)*a&t)<<i)),s-=4,++f;switch(s){case 3:c^=(n[f+2]&r)<<i;case 2:c^=(n[f+1]&r)<<8;case 1:c=((c^=n[f]&r)&t)*a+(((c>>>i)*a&t)<<i)}return c=((c^=c>>>13)&t)*a+(((c>>>16)*a&t)<<16),(c^=c>>>15)>>>0},c=(n,e)=>(void 0===e&&(e=n,n=0),(()=>{const n=o[0],e=o[1],a=o[2],s=o[3],c=0|33103+t*n,f=0|63335+t*e+(r*n+(c>>>16)),l=0|31614+t*a+r*e+(62509*n+(f>>>16));o[0]=c,o[1]=f,o[2]=l,o[3]=5125+t*s+(r*a+62509*e)+(22609*n+(l>>>16));const d=(s<<21)+((s>>2^a)<<5)+((a>>2^e)>>11);return i*((d>>>(s>>11)|d<<(31&-(s>>11)))>>>0)})()*(e-n)+n),f=n=>{return n.length?n[(i=n.length,e(c(i,void 0)))]:void 0;var i};class l{constructor(e,i={}){if(!e.capabilities.floatFragmentTextures)throw new Error("No OES_texture_float support for float textures.");this.renderer=e,this.defines={},this.uniforms=i,this.uniforms.u_camera={value:new THREE.Vector3},this.uniforms.u_viewMatrix={value:null},this.uniforms.u_projectionMatrix={value:null},this.uniforms.u_resolution={value:new THREE.Vector2},this.uniforms.u_delta={value:0},this.uniforms.u_time={value:0},this.uniforms.u_frame={value:0},this.buffers=[],this.doubleBuffers=[],this.background=null,this.main=null,this.sceneBuffer=null,this.postprocessing=null,this.billboard_scene=new THREE.Scene,this.billboard_camera=new THREE.Camera,this.billboard_camera.position.z=1,this.passThruUniforms={texture:{value:null}},this.passThruShader=n("uniform sampler2D texture;\n    uniform vec2 u_resolution;\n    void main() {\n        vec2 uv = gl_FragCoord.xy / u_resolution.xy;\n        gl_FragColor = texture2D( texture, uv );\n    }",this.passThruUniforms),this.mesh=new THREE.Mesh(new THREE.PlaneGeometry(2,2),this.passThruShader),this.billboard_scene.add(this.mesh),this.clock=new THREE.Clock,this.frame=0,this.lastTime=0,this.time=0,this.resolution=new THREE.Vector2(e.domElement.width,e.domElement.height)}getBufferSize(n,e){const i=new RegExp(`uniform\\s*sampler2D\\s*${e}\\;\\s*\\/\\/*\\s(\\d+)x(\\d+)`,"gm").exec(n);if(i)return{width:parseInt(i[1]),height:parseInt(i[2])};const t=new RegExp(`uniform\\s*sampler2D\\s*${e}\\;\\s*\\/\\/*\\s(\\d*\\.\\d+|\\d+)`,"gm").exec(n);if(t){if(2<t.length)return{width:parseFloat(t[1]),height:parseFloat(t[2])};if(1<t.length)return{width:parseFloat(t[1]),height:parseFloat(t[1])}}return{width:1,height:1}}load(e){e.match(/(?:^\s*)((?:#if|#elif)(?:\s*)(defined\s*\(\s*BACKGROUND)(?:\s*\))|(?:#ifdef)(?:\s*BACKGROUND)(?:\s*))/gm)&&(this.renderer.autoClearColor=!1,this.addBackground(e));const i=e.match(/(?:^\s*)((?:#if|#elif)(?:\s*)(defined\s*\(\s*BUFFER_)(\d+)(?:\s*\))|(?:#ifdef)(?:\s*BUFFER_)(\d+)(?:\s*))/gm);if(i)for(let n,t=0;t<i.length;t++)n=this.getBufferSize(e,`u_buffer${t}`),this.addBuffer(e,n.width,n.height);const t=e.match(/(?:^\s*)((?:#if|#elif)(?:\s*)(defined\s*\(\s*DOUBLE_BUFFER_)(\d+)(?:\s*\))|(?:#ifdef)(?:\s*DOUBLE_BUFFER_)(\d+)(?:\s*))/gm);if(t){this.renderer.autoClearColor=!1;for(let n,i=0;i<t.length;i++)n=this.getBufferSize(e,`u_doubleBuffer${i}`),this.addDoubleBuffer(e,n.width,n.height)}this.main=n(e,this.uniforms),e.match(/(?:^\s*)((?:#if|#elif)(?:\s*)(defined\s*\(\s*POSTPROCESSING)(?:\s*\))|(?:#ifdef)(?:\s*POSTPROCESSING)(?:\s*))/gm)&&this.addPostprocessing(e)}addBackground(e){return this.background=n(`#define BACKGROUND\n${e}`,this.uniforms),this.background.defines=this.defines,this.background}addBuffer(e,i,t){let r=this.buffers.length,o=n(`#define BUFFER_${r}\n${e}`,this.uniforms);o.defines=this.defines;let a={name:`u_buffer${r}`,material:o,renderTarget:null,width:i,height:t,wrapS:THREE.RepeatWrapping,wrapT:THREE.RepeatWrapping,minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter};return this.buffers.push(a),this.uniforms[a.name]={value:null},a.renderTarget=this.createRenderTarget(a),a}addDoubleBuffer(e,i,t){let r=this.doubleBuffers.length,o=n(`#define DOUBLE_BUFFER_${r}\n${e}`,this.uniforms);o.defines=this.defines;let a={name:`u_doubleBuffer${r}`,material:o,renderTargets:[],width:i,height:t,wrapS:THREE.RepeatWrapping,wrapT:THREE.RepeatWrapping,minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter};return this.doubleBuffers.push(a),this.uniforms[a.name]={value:null},a.renderTargets[0]=this.createRenderTarget(a),a.renderTargets[1]=this.createRenderTarget(a),a}addPostprocessing(e){return this.postprocessing=n(`#define POSTPROCESSING\n${e}`,this.uniforms),this.postprocessing.defines=this.defines,this.sceneBuffer={renderTarget:null,width:this.renderer.domElement.width,height:this.renderer.domElement.height},this.uniforms.u_scene={value:null},this.sceneBuffer.renderTarget=this.createRenderTarget({width:this.sceneBuffer.width,height:this.sceneBuffer.height,wrapS:null,wrapT:null,minFilter:THREE.LinearFilter,magFilter:THREE.LinearFilter}),this.sceneBuffer}createRenderTarget(n){n.wrapS=n.wrapS||THREE.ClampToEdgeWrapping,n.wrapT=n.wrapT||THREE.ClampToEdgeWrapping,n.minFilter=n.minFilter||THREE.NearestFilter,n.magFilter=n.magFilter||THREE.NearestFilter;let i=THREE.FloatType;!1===this.renderer.capabilities.isWebGL2&&(i=THREE.HalfFloatType);let t=n.width,r=n.height;return 1>=t&&1>=r&&(t*=this.renderer.domElement.width,r*=this.renderer.domElement.height),new THREE.WebGLRenderTarget(e(t),e(r),{wrapS:n.wrapS,wrapT:n.wrapT,minFilter:n.minFilter,magFilter:n.magFilter,format:THREE.RGBAFormat,type:/(iPad|iPhone|iPod)/g.test(navigator.userAgent)?THREE.HalfFloatType:i,stencilBuffer:!1})}updateUniforms(n=null){this.time=this.clock.getElapsedTime(),this.uniforms.u_time.value=this.time,this.uniforms.u_delta.value=this.time-this.lastTime,this.uniforms.u_frame.value=this.frame,n&&(this.uniforms.u_camera.value=n.position,this.uniforms.u_projectionMatrix.value=n.projectionMatrix,this.uniforms.u_viewMatrix.value=n.matrixWorldInverse),this.lastTime=this.time,this.frame++}updateBuffers(){for(let n,i=0,t=this.buffers.length;i<t;i++)n=this.buffers[i],this.uniforms.u_resolution.value=1>=n.width&&1>=n.height?new THREE.Vector2(e(this.resolution.x*n.width),e(this.resolution.y*n.height)):new THREE.Vector2(n.width,n.height),this.renderTarget(n.material,n.renderTarget),this.uniforms[n.name].value=n.renderTarget.texture;let n=this.frame%2,i=(this.frame+1)%2;for(let t,r=0,o=this.doubleBuffers.length;r<o;r++)t=this.doubleBuffers[r],this.uniforms.u_resolution.value=1>=t.width&&1>=t.height?new THREE.Vector2(e(this.resolution.x*t.width),e(this.resolution.y*t.height)):new THREE.Vector2(t.width,t.height),this.uniforms[t.name].value=t.renderTargets[n].texture,this.renderTarget(t.material,t.renderTargets[i]);this.renderer.setRenderTarget(null)}renderBackground(){this.background&&(this.mesh.material=this.background,this.renderer.render(this.billboard_scene,this.billboard_camera),this.mesh.material=this.passThruShader)}getBufferTexture(n){return n>=this.buffers.length?void 0:this.buffers[n].renderTarget.texture}getDoubleBufferTexture(n){return n>=this.doubleBuffers.length?void 0:this.doubleBuffers[n].renderTargets[this.frame%2].texture}renderBuffer(n){n>=this.buffers.length||(this.uniforms.u_resolution.value=this.resolution,this.passThruUniforms.texture.value=this.geBufferTexture(n),this.mesh.material=this.passThruShader,this.renderer.render(this.billboard_scene,this.billboard_camera))}renderDoubleBuffer(n){n>=this.doubleBuffers.length||(this.uniforms.u_resolution.value=this.resolution,this.passThruUniforms.texture.value=this.getDoubleBufferTexture(n),this.mesh.material=this.passThruShader,this.renderer.render(this.billboard_scene,this.billboard_camera))}renderMain(){this.updateUniforms(),this.updateBuffers(),this.uniforms.u_resolution.value=this.resolution,this.mesh.material=this.material,this.renderer.render(this.billboard_scene,this.billboard_camera),this.mesh.material=this.passThruShader}renderScene(n,e){this.updateUniforms(e),this.updateBuffers(),this.uniforms.u_resolution.value=this.resolution,this.uniforms.u_camera.value=e.position,this.sceneBuffer&&(this.renderer.setRenderTarget(this.sceneBuffer.renderTarget),this.renderer.clear()),this.renderBackground(),this.renderer.render(n,e),this.sceneBuffer&&(this.renderer.setRenderTarget(null),this.renderer.clear(),this.uniforms.u_resolution.value=this.resolution,this.uniforms.u_scene.value=this.sceneBuffer.renderTarget.texture,this.mesh.material=this.postprocessing,this.renderer.render(this.billboard_scene,this.billboard_camera),this.mesh.material=this.passThruShader)}renderTarget(n,e){this.mesh.material=n,this.renderer.setRenderTarget(e),this.renderer.clear(),this.renderer.render(this.billboard_scene,this.billboard_camera,e),this.mesh.material=this.passThruShader}setSize(n,i){n*=window.devicePixelRatio,i*=window.devicePixelRatio,this.sceneBuffer&&(this.sceneBuffer.width=n,this.sceneBuffer.height=i,this.sceneBuffer.renderTarget.setSize(n,i)),this.resolution=new THREE.Vector2(n,i),this.uniforms.u_resolution.value=this.resolution;for(let e,t=0;t<this.buffers.length;t++)e=this.buffers[t],1>=e.width&&1>=e.height&&e.renderTarget.setSize(e.width*n,e.height*i);for(let t=0;t<this.doubleBuffers.length;t++){this.renderer.autoClearColor=!1;let r=this.doubleBuffers[t];if(1>=r.width&&1>=r.height){let t=e(r.width*n),o=e(r.height*i);r.renderTargets[0].setSize(t,o),r.renderTargets[1].setSize(t,o)}}this.frame=0}}const d={defines:{BUBBLE_ELEVATION:[.001,.4],BUBBLE_SHIFT:[-.9,-.5,0,0,0,0,.5,.9],TIME_OFFSET:[.001,100],SIMULATION_SPEED:[.6,1],ATMOSPHERE_INTENSITY:[.9,1],ATMOSPHERE_SUN_POWER:[8,15],ATMOSPHERE_ELEVATION:[.25,.9],ATMOSPHERE_FAST:[0,0,0,0,1],GROUND_INTENSITY:[.5,1],GROUND_HUE:[.001,1],EQUIRECT_ANGLE:[-3.1415,3.1415],EQUIRECT_TILT:[-3.1415,3.1415],STREAM_INTENSITY:[0,.45],STREAM_TYPE:[0,1],STREAM_AMOUNT:[.15,.3],STREAM_GRID_X:[75,200],STREAM_GRID_Y:[50,200],STREAM_SPEED:[.25,2],FIELD_GRID:[50,80],FIELD_SPEED:[.25,.9],FIELD_INTENSITY:[.2,.3],LIGHT_FLARE_INTENSITY:[.001,3]},filter:[["STREAM_INTENSITY","STREAM_INTENSITY","FIELD_INTENSITY"]]},E='\nuniform sampler2D   u_scene; \nuniform sampler2D   u_buffer0; // 512x512\nuniform sampler2D   u_doubleBuffer0; // 512x512\n\nuniform mat4        u_viewMatrix;\nuniform mat4        u_projectionMatrix;\n\nuniform vec3        u_camera;\nuniform vec3        u_light;\nuniform vec2        u_resolution;\nuniform float       u_time;\nuniform int         u_frame;\n\nvarying vec4        v_position;\n#ifdef MODEL_VERTEX_NORMAL\nvarying vec3        v_normal;\n#endif\nvarying vec2        v_texcoord;\n\n#define RANDOM_SCALE vec4(443.897, 441.423, .0973, .1099)\n#define SHARPENFAST_KERNELSIZE 2\n#define SHARPENFAST_TYPE vec3\n#define SHARPENFAST_SAMPLER_FNC(TEX, UV) texture2D(TEX, UV).rgb\n#define TAU 6.2831853071795864769252867665590\n#define PI 3.1415926535897932384626433832795\n#define HALF_PI 1.5707963267948966192313216916398\n\n// unnneded\n#define PLATFORM_WEBGL\n#define QTR_PI 0.78539816339\n#define TWO_PI 6.2831853071795864769252867665590\n#define INV_PI 0.31830988618379067153776752674503\n#define INV_SQRT_TAU 0.39894228040143267793994605993439\n#define SQRT_HALF_PI 1.25331413732\n#define PHI 1.618033988749894848204586834\n#define EPSILON 0.0000001\n#define GOLDEN_RATIO 1.6180339887\n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#define GOLDEN_ANGLE 2.39996323\n#define RANDOM_SCALE vec4(443.897, 441.423, .0973, .1099)\n#define SAMPLEFXAA_SAMPLE_FNC(TEX, UV) texture2D(TEX, UV)\n#undef CENTER_2D\n#undef CENTER_3D\n#undef CENTER_4D\n#undef FNC_QUATMULT\n#undef RANDOM_SINLESS\n#undef SAMPLEEQUIRECT_FLIP_Y\n#define NOISED_RANDOM2_FNC srandom2\n#define NOISED_RANDOM3_FNC srandom3\n#define TONEMAP_FNC tonemapReinhardJodie\n#undef GAMMA\n#undef STR_RAY\n#define HENYEYGREENSTEIN_SCATTERING 0.76\n#define ATMOSPHERE_ORIGIN vec3(0.0)\n#define ATMOSPHERE_RADIUS_MIN 6360e3\n#define ATMOSPHERE_RADIUS_MAX 6420e3\n#define ATMOSPHERE_LIGHT_SAMPLES 4\n#define ATMOSPHERE_SAMPLES 4\n#define SAMPLEEQUIRET_ITERATIONS 6\n#define SAMPLER_FNC(TEX, UV) texture2D(TEX, UV)\n#define SAMPLER_TYPE sampler2D\n#define SAMPLEFXAA_REDUCE_MIN   (1.0/128.0)\n#define SAMPLEFXAA_REDUCE_MUL   (1.0/8.0)\n#define SAMPLEFXAA_SPAN_MAX     8.0\n#define SAMPLEFXAA_SAMPLE_FNC(TEX, UV) texture2D(TEX, UV)\n#define SAMPLE_TRIPLANAR_FNC(TEX, UV) texture2D(TEX, UV)\n\n\n//  Switches\n//\n// #define ATMOSPHERE_FAST\n\n// #ifndef GROUND_INTENSITY\n// #define GROUND_INTENSITY 0.5\n// #endif  \n\n// #ifndef LIGHT_FLARE_INTENSITY\n// #define LIGHT_FLARE_INTENSITY 4.0\n// #endif\n\n// #ifndef STREAM_INTENSITY\n// #define STREAM_INTENSITY 0.2\n// #endif\n\n// #ifndef FIELD_INTENSITY\n// #define FIELD_INTENSITY 1.\n// #endif\n\n// Properties\n// \n#ifndef SIMULATION_SPEED\n#define SIMULATION_SPEED 0.5\n#endif\n\n#ifndef ATMOSPHERE_INTENSITY\n#define ATMOSPHERE_INTENSITY 1.0\n#endif\n\n#ifndef ATMOSPHERE_SUN_POWER\n#define ATMOSPHERE_SUN_POWER 10.0\n#endif\n\n#ifndef ATMOSPHERE_ELEVATION\n#define ATMOSPHERE_ELEVATION 0.75\n#endif\n\n#ifndef TIME_OFFSET\n#define TIME_OFFSET 0.0\n#endif\n\n\n#ifndef GROUND_HUE\n// #define GROUND_HUE random(decimate(u_time * 0.1, 10.0))\n#define GROUND_HUE 0.0\n#endif\n\n#ifndef STREAM_SPEED\n#define STREAM_SPEED 0.5\n#endif\n\n#ifndef STREAM_GRID_X\n#define STREAM_GRID_X 200.0\n#endif\n\n#ifndef STREAM_GRID_Y\n#define STREAM_GRID_Y 200.0\n#endif\n\n#ifndef STREAM_TYPE\n#define STREAM_TYPE 0.0\n#endif\n\n#ifndef STREAM_AMOUNT\n#define STREAM_AMOUNT 0.2\n#endif\n\n#ifndef FIELD_GRID\n#define FIELD_GRID 60.0\n#endif\n\n#ifndef FIELD_SPEED\n#define FIELD_SPEED 0.0\n#endif\n\n#ifndef LIGHT_POSITION\n// #define LIGHT_POSITION normalize(u_camera * vec3(1.0, 0.0, 1.0) + vec3(sin(TIME_OFFSET + u_time * 0.2), sin(TIME_OFFSET + u_time * 0.1) * 0.25 + 0.5, cos( TIME_OFFSET + u_time * 0.12)))\n#define LIGHT_POSITION normalize(u_camera * vec3(1.0, 0.0, 1.0) + vec3(sin(TIME_OFFSET + u_time * 0.2), sin(TIME_OFFSET + u_time * 0.1) * 0.3 + 0.5, cos( TIME_OFFSET + u_time * 0.12)))\n// #define LIGHT_POSITION normalize(vec3(sin(TIME_OFFSET + u_time * 2.0), sin(TIME_OFFSET + u_time) * 0.3 + 0.5, cos( TIME_OFFSET + u_time * 1.2)))\n// #define LIGHT_POSITION normalize(vec3(sin(TIME_OFFSET), sin(TIME_OFFSET) * 0.5 + 0.5, cos( TIME_OFFSET )))\n// #define LIGHT_POSITION (vec3(sin(TIME_OFFSET + u_time * 0.2), sin(TIME_OFFSET + u_time * 0.1) * 0.5 + 0.5, cos(TIME_OFFSET + u_time * 0.12)))\n#endif\n\n\nvec3 enviroment(vec3 normal, float r, float m);\n#define ENVMAP_FNC(N, R, M) enviroment(N, R, M)\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: some useful math constants\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n#ifndef EIGHTH_PI\n#define EIGHTH_PI 0.39269908169\n#endif\n#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef INV_PI\n#define INV_PI 0.31830988618379067153776752674503\n#endif\n#ifndef INV_SQRT_TAU\n#define INV_SQRT_TAU 0.39894228040143267793994605993439  // 1.0/SQRT_TAU\n#endif\n#ifndef SQRT_HALF_PI\n#define SQRT_HALF_PI 1.25331413732\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n#ifndef GOLDEN_RATIO\n#define GOLDEN_RATIO 1.6180339887\n#endif\n#ifndef GOLDEN_RATIO_CONJUGATE \n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#endif\n#ifndef GOLDEN_ANGLE // (3.-sqrt(5.0))*PI radians\n#define GOLDEN_ANGLE 2.39996323\n#endif\n#ifndef DEG2RAD\n#define DEG2RAD (PI / 180.0)\n#endif\n#ifndef RAD2DEG\n#define RAD2DEG (180.0 / PI)\n#endif\n\n\n\n/*\ncontributors: Ian Heisters\ndescription: Transforms the input signal into a triangle wave. For instance, if x goes between 0 and 2, the returned value will go from 0 to 1, and then 1 to 0 in a triangle shape.\nuse: <float|vec2> mirror(<float|vec2> x)\nexamples:\n    - https://raw.githubusercontent.com/patriciogonzalezvivo/lygia_examples/main/math_functions.frag\n*/\n\n#ifndef FNC_MIRROR\n#define FNC_MIRROR\nfloat mirror(in float x) {\n    float f = fract(x);\n    float m = floor(mod(x, 2.));\n    float fm = f * m;\n    return f + m - fm * 2.;\n}\n\nvec2 mirror(in vec2 v) {\n    vec2 f = fract(v);\n    vec2 m = floor(mod(v, 2.));\n    vec2 fm = f * m;\n    return f + m - fm * 2.;\n}\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: decimate a value with an specific precision\nuse: <float|vec2|vec3|vec4> decimate(<float|vec2|vec3|vec4> value, <float|vec2|vec3|vec4> precision)\nexamples:\n    - https://raw.githubusercontent.com/patriciogonzalezvivo/lygia_examples/main/math_functions.frag\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_DECIMATE\n#define FNC_DECIMATE\nfloat decimate(float v, float p){ return floor(v*p)/p; }\nvec2 decimate(vec2 v, float p){ return floor(v*p)/p; }\nvec2 decimate(vec2 v, vec2 p){ return floor(v*p)/p; }\nvec3 decimate(vec3 v, float p){ return floor(v*p)/p; }\nvec3 decimate(vec3 v, vec3 p){ return floor(v*p)/p; }\nvec4 decimate(vec4 v, float p){ return floor(v*p)/p; }\nvec4 decimate(vec4 v, vec4 p){ return floor(v*p)/p; }\n#endif\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: returns a 3x3 rotation matrix\nuse: <mat3> rotate3dX(<float> radians)\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_ROTATE3DX\n#define FNC_ROTATE3DX\nmat3 rotate3dX(const in float r){\n    float c = cos(r);\n    float s = sin(r);\n    return mat3(vec3(1.0,0.0,0.0),\n                vec3(0.0,c,s),\n                vec3(0.0,-s,c));\n}\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: returns a 3x3 rotation matrix\nuse: <mat3> rotate3dZ(<float> radians)\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_ROTATE3DZ\n#define FNC_ROTATE3DZ\nmat3 rotate3dZ(const in float r){\n    float c = cos(r);\n    float s = sin(r);\n    return mat3(vec3(c,s,0.),\n                vec3(-s,c,0.),\n                vec3(0.,0.,1.));\n}\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Squared length\nuse: <vec4|vec3|vec2> lengthSq(<vec4|vec3|vec2> v)\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_LENGTHSQ\n#define FNC_LENGTHSQ\n\nfloat lengthSq(in vec2 v) { return dot(v, v); }\nfloat lengthSq(in vec3 v) { return dot(v, v); }\nfloat lengthSq(in vec4 v) { return dot(v, v); }\n\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: given a 4x4 returns a 3x3\nuse: <mat4> toMat3(<mat3> m)\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_TOMAT3\n#define FNC_TOMAT3\nmat3 toMat3(mat4 m) {\n    #if __VERSION__ >= 300\n    return mat3(m);\n    #else\n    return mat3(m[0].xyz, m[1].xyz, m[2].xyz);\n    #endif\n}\n#endif\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: "Fix the aspect ratio of a space keeping things squared for you, \nin     a similar way that aspect.glsl does, but while scaling the \nspace to keep the     entire 0.0,0.0 ~ 1.0,1.0 range visible\n"\nuse: <vec2> ratio(<vec2> st, <vec2> st_size)\nexamples:\n    - https://raw.githubusercontent.com/patriciogonzalezvivo/lygia_examples/main/draw_shapes.frag\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_RATIO\n#define FNC_RATIO\nvec2 ratio(in vec2 v, in vec2 s) {\n    return mix( vec2((v.x*s.x/s.y)-(s.x*.5-s.y*.5)/s.y,v.y),\n                vec2(v.x,v.y*(s.y/s.x)-(s.y*.5-s.x*.5)/s.x),\n                step(s.x,s.y));\n}\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: scale a 2D space variable\nuse: scale(<vec2> st, <vec2|float> scale_factor [, <vec2> center])\noptions:\n    - CENTER_2D\n    - CENTER_3D\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_SCALE\n#define FNC_SCALE\nvec2 scale(in float st, in float s, in vec2 center) { return (st - center) * s + center; }\nvec2 scale(in float st, in float s) {\n#ifdef CENTER_2D\n    return scale(st,  s, CENTER_2D);\n#else\n    return scale(st,  s, vec2(0.5));\n#endif\n}\n\nvec2 scale(in vec2 st, in vec2 s, in vec2 center) { return (st - center) * s + center; }\nvec2 scale(in vec2 st, in float s, in vec2 center) { return scale(st, vec2(s), center); }\nvec2 scale(in vec2 st, in vec2 s) {\n#ifdef CENTER_2D\n    return (st - CENTER_2D) * s + CENTER_2D;\n#else\n    return (st - 0.5) * s + 0.5;\n#endif\n}\n\nvec2 scale(in vec2 st, in float s) {\n#ifdef CENTER_2D\n    return (st - CENTER_2D) * s + CENTER_2D;\n#else\n    return (st - 0.5) * s + 0.5;\n#endif\n}\n\nvec3 scale(in vec3 st, in vec3 s, in vec3 center) { return (st - center) * s + center; }\nvec3 scale(in vec3 st, in float s, in vec3 center) { return (st - center) * s + center; }\nvec3 scale(in vec3 st, in vec3 s) {\n#ifdef CENTER_3D\n    return (st - CENTER_3D) * s + CENTER_3D;\n#else\n    return (st - 0.5) * s + 0.5;\n#endif\n}\n\nvec3 scale(in vec3 st, in float s) {\n#ifdef CENTER_3D\n    return (st - CENTER_3D) * s + CENTER_3D;\n#else\n    return (st - 0.5) * s + 0.5;\n#endif\n}\n\n// For tiles\nvec4 scale(in vec4 st, float s) { return vec4(scale(st.xy, s), st.zw); }\nvec4 scale(in vec4 st, vec2 s) { return vec4(scale(st.xy, s), st.zw); }\n#endif\n\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: returns a 2x2 rotation matrix\nuse: <mat2> rotate2d(<float> radians)\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_ROTATE2D\n#define FNC_ROTATE2D\nmat2 rotate2d(const in float r){\n    float c = cos(r);\n    float s = sin(r);\n    return mat2(c, s, -s, c);\n}\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: returns a 4x4 rotation matrix\nuse: <mat4> rotate4d(<vec3> axis, <float> radians)\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_ROTATE4D\n#define FNC_ROTATE4D\nmat4 rotate4d(in vec3 a, const in float r) {\n    a = normalize(a);\n    float s = sin(r);\n    float c = cos(r);\n    float oc = 1.0 - c;\n    vec4 col1 = vec4(oc * a.x * a.x + c, oc * a.x * a.y + a.z * s, oc * a.z * a.x - a.y * s, 0.0);\n    vec4 col2 = vec4(oc * a.x * a.y - a.z * s, oc * a.y * a.y + c, oc * a.y * a.z + a.x * s, 0.0);\n    vec4 col3 = vec4(oc * a.z * a.x + a.y * s, oc * a.y * a.z - a.x * s, oc * a.z * a.z + c, 0.0);\n    vec4 col4 = vec4(0.0, 0.0, 0.0, 1.0);\n    return mat4(col1, col2, col3, col4);\n}\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: rotate a 2D space by a radian r\nuse: rotate(<vec3|vec2> v, float r [, vec2 c])\noptions:\n    - CENTER_2D\n    - CENTER_3D\n    - CENTER_4D\nexamples:\n    - https://raw.githubusercontent.com/patriciogonzalezvivo/lygia_examples/main/draw_shapes.frag\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_ROTATE\n#define FNC_ROTATE\nvec2 rotate(in vec2 v, in float r, in vec2 c) {\n    return rotate2d(r) * (v - c) + c;\n}\n\nvec2 rotate(in vec2 v, in float r) {\n    #ifdef CENTER_2D\n    return rotate(v, r, CENTER_2D);\n    #else\n    return rotate(v, r, vec2(.5));\n    #endif\n}\n\nvec2 rotate(vec2 v, vec2 x_axis) {\n    #ifdef CENTER_2D\n    v -= CENTER_2D;\n    #endif\n    vec2 rta = vec2( dot(v, vec2(-x_axis.y, x_axis.x)), dot(v, x_axis) );\n    #ifdef CENTER_2D\n    rta += CENTER_2D;\n    #endif\n    return rta;\n}\n\nvec3 rotate(in vec3 v, in float r, in vec3 axis, in vec3 c) {\n    return (rotate4d(axis, r) * vec4(v - c, 1.)).xyz + c;\n}\n\nvec3 rotate(in vec3 v, in float r, in vec3 axis) {\n    #ifdef CENTER_3D\n    return rotate(v, r, axis, CENTER_3D);\n    #else\n    return rotate(v, r, axis, vec3(0.));\n    #endif\n}\n\nvec4 rotate(in vec4 v, in float r, in vec3 axis, in vec4 c) {\n    return rotate4d(axis, r) * (v - c) + c;\n}\n\nvec4 rotate(in vec4 v, in float r, in vec3 axis) {\n    #ifdef CENTER_4D\n    return rotate(v, r, axis, CENTER_4D);\n    #else\n    return rotate(v, r, axis, vec4(0.));\n    #endif\n}\n\n#if defined(FNC_QUATMULT)\nvec3 rotate(QUAT q, vec3 v) {\n    QUAT q_c = QUAT(-q.x, -q.y, -q.z, q.w);\n    return quatMul(q, quatMul(vec4(v, 0), q_c)).xyz;\n}\n\nvec3 rotate(QUAT q, vec3 v, vec3 c) {\n    vec3 dir = v - c;\n    return c + rotate(q, dir);\n}\n#endif\n\n#endif\n\n\n\n/*\ncontributors:  Shadi El Hajj\ndescription: Create a look-at view matrix\nuse: <mat4> lookAtView(in <vec3> position, in <vec3> target, in <vec3> up)\nlicense: MIT License (MIT) Copyright (c) 2024 Shadi EL Hajj\n*/\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: create a look at matrix. Right handed by default.\nuse:\n    - <mat3> lookAt(<vec3> forward, <vec3> up)\n    - <mat3> lookAt(<vec3> eye, <vec3> target, <vec3> up)\n    - <mat3> lookAt(<vec3> eye, <vec3> target, <float> roll)\n    - <mat3> lookAt(<vec3> forward)\noptions:\n    - LOOK_AT_LEFT_HANDED: assume a left-handed coordinate system\n    - LOOK_AT_RIGHT_HANDED: assume a right-handed coordinate system\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_LOOKAT\n#define FNC_LOOKAT\n\nmat3 lookAt(vec3 forward, vec3 up) {\n    vec3 zaxis = normalize(forward);\n#if defined(LOOK_AT_RIGHT_HANDED)\n    vec3 xaxis = normalize(cross(zaxis, up));\n    vec3 yaxis = cross(xaxis, zaxis);\n#else\n    vec3 xaxis = normalize(cross(up, zaxis));\n    vec3 yaxis = cross(zaxis, xaxis);\n#endif\n    return mat3(xaxis, yaxis, zaxis);\n}\n\nmat3 lookAt(vec3 eye, vec3 target, vec3 up) {\n    vec3 forward = normalize(target - eye);\n    return lookAt(forward, up);\n}\n\nmat3 lookAt(vec3 eye, vec3 target, float roll) {\n    vec3 up = vec3(sin(roll), cos(roll), 0.0);\n    return lookAt(eye, target, up);\n}\n\nmat3 lookAt(vec3 forward) {\n    return lookAt(forward, vec3(0.0, 1.0, 0.0));\n}\n\n#endif\n\n\n/*\ncontributors:  Shadi El Hajj\ndescription: Add a translation component to a transform matrix\nuse: <mat4> translate(in <mat3> matrix, in <vec3> tranaslation)\nlicense: MIT License (MIT) Copyright (c) 2024 Shadi EL Hajj\n*/\n\n#ifndef FNC_TRANSLATE\n#define FNC_TRANSLATE\n\n mat4 translate(mat3 m, vec3 translation) {\n    return mat4(\n        vec4(m[0], 0.0),\n        vec4(m[1], 0.0),\n        vec4(m[2], 0.0),\n        vec4(translation, 1.0)\n    );\n}\n\n#endif\n\n\n\n#ifndef FNC_LOOKATVIEW\n#define FNC_LOOKATVIEW\n\nmat4 lookAtView( in vec3 position, in vec3 target, in vec3 up ) {\n    mat3 m = lookAt(position, target, up);\n    return translate(m, position);\n}\n\nmat4 lookAtView( in vec3 position, in vec3 target, in float roll ) {\n    mat3 m = lookAt(position, target, roll);\n    return translate(m, position);\n}\n\nmat4 lookAtView( in vec3 position, in vec3 lookAt ) {\n    return lookAtView(position, lookAt, vec3(0.0, 1.0, 0.0));\n}\n\n#endif\n\n\n/*\ncontributors: ["Patricio Gonzalez Vivo", "David Hoskins", "Inigo Quilez"]\ndescription: Pass a value and get some random normalize value between 0 and 1\nuse: float random[2|3](<float|vec2|vec3> value)\noptions:\n    - RANDOM_HIGHER_RANGE: for working with a range over 0 and 1\n    - RANDOM_SINLESS: Use sin-less random, which tolerates bigger values before producing pattern. From https://www.shadertoy.com/view/4djSRW\n    - RANDOM_SCALE: by default this scale if for number with a big range. For producing good random between 0 and 1 use bigger range\nexamples:\n    - /shaders/generative_random.frag\nlicense:\n    - MIT License (MIT) Copyright 2014, David Hoskins\n*/\n\n#ifndef RANDOM_SCALE\n#ifdef RANDOM_HIGHER_RANGE\n#define RANDOM_SCALE vec4(.1031, .1030, .0973, .1099)\n#else\n#define RANDOM_SCALE vec4(443.897, 441.423, .0973, .1099)\n#endif\n#endif\n\n#ifndef FNC_RANDOM\n#define FNC_RANDOM\nfloat random(in float x) {\n#ifdef RANDOM_SINLESS\n    x = fract(x * RANDOM_SCALE.x);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n#else\n    return fract(sin(x) * 43758.5453);\n#endif\n}\n\nfloat random(in vec2 st) {\n#ifdef RANDOM_SINLESS\n    vec3 p3  = fract(vec3(st.xyx) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n#else\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n#endif\n}\n\nfloat random(in vec3 pos) {\n#ifdef RANDOM_SINLESS\n    pos  = fract(pos * RANDOM_SCALE.xyz);\n    pos += dot(pos, pos.zyx + 31.32);\n    return fract((pos.x + pos.y) * pos.z);\n#else\n    return fract(sin(dot(pos.xyz, vec3(70.9898, 78.233, 32.4355))) * 43758.5453123);\n#endif\n}\n\nfloat random(in vec4 pos) {\n#ifdef RANDOM_SINLESS\n    pos = fract(pos * RANDOM_SCALE);\n    pos += dot(pos, pos.wzxy + 33.33);\n    return fract((pos.x + pos.y) * (pos.z + pos.w));\n#else\n    float dot_product = dot(pos, vec4(12.9898,78.233,45.164,94.673));\n    return fract(sin(dot_product) * 43758.5453);\n#endif\n}\n\nvec2 random2(float p) {\n    vec3 p3 = fract(vec3(p) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec2 random2(vec2 p) {\n    vec3 p3 = fract(p.xyx * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec2 random2(vec3 p3) {\n    p3 = fract(p3 * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec3 random3(float p) {\n    vec3 p3 = fract(vec3(p) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xxy + p3.yzz) * p3.zyx); \n}\n\nvec3 random3(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nvec3 random3(vec3 p) {\n    p = fract(p * RANDOM_SCALE.xyz);\n    p += dot(p, p.yxz + 19.19);\n    return fract((p.xxy + p.yzz) * p.zyx);\n}\n\nvec4 random4(float p) {\n    vec4 p4 = fract(p * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);   \n}\n\nvec4 random4(vec2 p) {\n    vec4 p4 = fract(p.xyxy * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nvec4 random4(vec3 p) {\n    vec4 p4 = fract(p.xyzx * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nvec4 random4(vec4 p4) {\n    p4 = fract(p4  * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Signed Random\nuse: srandomX(<vec2|vec3> x)\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_SRANDOM\n#define FNC_SRANDOM\n\nfloat srandom(in float x) {\n  return -1. + 2. * fract(sin(x) * 43758.5453);\n}\n\nfloat srandom(in vec2 st) {\n  return -1. + 2. * fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n}\n\nfloat srandom(in vec3 pos) {\n  return -1. + 2. * fract(sin(dot(pos.xyz, vec3(70.9898, 78.233, 32.4355))) * 43758.5453123);\n}\n\nfloat srandom(in vec4 pos) {\n    float dot_product = dot(pos, vec4(12.9898,78.233,45.164,94.673));\n    return -1. + 2. * fract(sin(dot_product) * 43758.5453);\n}\n\nvec2 srandom2(in vec2 st) {\n    const vec2 k = vec2(.3183099, .3678794);\n    st = st * k + k.yx;\n    return -1. + 2. * fract(16. * k * fract(st.x * st.y * (st.x + st.y)));\n}\n\nvec3 srandom3(in vec3 p) {\n    p = vec3( dot(p, vec3(127.1, 311.7, 74.7)),\n            dot(p, vec3(269.5, 183.3, 246.1)),\n            dot(p, vec3(113.5, 271.9, 124.6)));\n    return -1. + 2. * fract(sin(p) * 43758.5453123);\n}\n\nvec2 srandom2(in vec2 p, const in float tileLength) {\n    p = mod(p, vec2(tileLength));\n    return srandom2(p);\n}\n\nvec3 srandom3(in vec3 p, const in float tileLength) {\n    p = mod(p, vec3(tileLength));\n    return srandom3(p);\n}\n\n#endif\n\n\n/*\ncontributors: Inigo Quilez\ndescription: Returns 2D/3D value noise in the first channel and in the rest the derivatives. For more details read this nice article http://www.iquilezles.org/www/articles/gradientnoise/gradientnoise.htm\nuse: noised(<vec2|vec3> space)\noptions:\n    NOISED_QUINTIC_INTERPOLATION: Quintic interpolation on/off. Default is off.\nexamples:\n    - /shaders/generative_noised.frag\n*/\n\n#ifndef NOISED_RANDOM2_FNC\n#define NOISED_RANDOM2_FNC srandom2\n#endif\n\n#ifndef NOISED_RANDOM3_FNC\n#define NOISED_RANDOM3_FNC srandom3\n#endif\n\n#ifndef FNC_NOISED\n#define FNC_NOISED\n\n// return gradient noise (in x) and its derivatives (in yz)\nvec3 noised (in vec2 p) {\n    // grid\n    vec2 i = floor( p );\n    vec2 f = fract( p );\n\n    // quintic interpolation\n    vec2 u = f * f * f * (f * (f * 6. - 15.) + 10.);\n    vec2 du = 30. * f * f * (f * (f - 2.) + 1.);\n\n    vec2 ga = NOISED_RANDOM2_FNC(i + vec2(0., 0.));\n    vec2 gb = NOISED_RANDOM2_FNC(i + vec2(1., 0.));\n    vec2 gc = NOISED_RANDOM2_FNC(i + vec2(0., 1.));\n    vec2 gd = NOISED_RANDOM2_FNC(i + vec2(1., 1.));\n\n    float va = dot(ga, f - vec2(0., 0.));\n    float vb = dot(gb, f - vec2(1., 0.));\n    float vc = dot(gc, f - vec2(0., 1.));\n    float vd = dot(gd, f - vec2(1., 1.));\n\n    return vec3( va + u.x*(vb-va) + u.y*(vc-va) + u.x*u.y*(va-vb-vc+vd),   // value\n                ga + u.x*(gb-ga) + u.y*(gc-ga) + u.x*u.y*(ga-gb-gc+gd) +  // derivatives\n                du * (u.yx*(va-vb-vc+vd) + vec2(vb,vc) - va));\n}\n\nvec4 noised (in vec3 pos) {\n    // grid\n    vec3 p = floor(pos);\n    vec3 w = fract(pos);\n\n    // quintic interpolant\n    vec3 u = w * w * w * ( w * (w * 6. - 15.) + 10. );\n    vec3 du = 30.0 * w * w * ( w * (w - 2.) + 1.);\n\n    // gradients\n    vec3 ga = NOISED_RANDOM3_FNC(p + vec3(0., 0., 0.));\n    vec3 gb = NOISED_RANDOM3_FNC(p + vec3(1., 0., 0.));\n    vec3 gc = NOISED_RANDOM3_FNC(p + vec3(0., 1., 0.));\n    vec3 gd = NOISED_RANDOM3_FNC(p + vec3(1., 1., 0.));\n    vec3 ge = NOISED_RANDOM3_FNC(p + vec3(0., 0., 1.));\n    vec3 gf = NOISED_RANDOM3_FNC(p + vec3(1., 0., 1.));\n    vec3 gg = NOISED_RANDOM3_FNC(p + vec3(0., 1., 1.));\n    vec3 gh = NOISED_RANDOM3_FNC(p + vec3(1., 1., 1.));\n\n    // projections\n    float va = dot(ga, w - vec3(0., 0., 0.));\n    float vb = dot(gb, w - vec3(1., 0., 0.));\n    float vc = dot(gc, w - vec3(0., 1., 0.));\n    float vd = dot(gd, w - vec3(1., 1., 0.));\n    float ve = dot(ge, w - vec3(0., 0., 1.));\n    float vf = dot(gf, w - vec3(1., 0., 1.));\n    float vg = dot(gg, w - vec3(0., 1., 1.));\n    float vh = dot(gh, w - vec3(1., 1., 1.));\n\n    // interpolations\n    return vec4( va + u.x*(vb-va) + u.y*(vc-va) + u.z*(ve-va) + u.x*u.y*(va-vb-vc+vd) + u.y*u.z*(va-vc-ve+vg) + u.z*u.x*(va-vb-ve+vf) + (-va+vb+vc-vd+ve-vf-vg+vh)*u.x*u.y*u.z,    // value\n                ga + u.x*(gb-ga) + u.y*(gc-ga) + u.z*(ge-ga) + u.x*u.y*(ga-gb-gc+gd) + u.y*u.z*(ga-gc-ge+gg) + u.z*u.x*(ga-gb-ge+gf) + (-ga+gb+gc-gd+ge-gf-gg+gh)*u.x*u.y*u.z +   // derivatives\n                du * (vec3(vb,vc,ve) - va + u.yzx*vec3(va-vb-vc+vd,va-vc-ve+vg,va-vb-ve+vf) + u.zxy*vec3(va-vb-ve+vf,va-vb-vc+vd,va-vc-ve+vg) + u.yzx*u.zxy*(-va+vb+vc-vd+ve-vf-vg+vh) ));\n}\n\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: "Physical Hue. \n\nRatio: \n* 1/3 = neon\n* 1/4 = refracted\n* 1/5+ = approximate white\n"\nuse: <vec3> hue(<float> hue[, <float> ratio])\nexamples:\n    - https://raw.githubusercontent.com/eduardfossas/lygia-study-examples/main/color/palette/hue.frag\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_PALETTE_HUE\n#define FNC_PALETTE_HUE\nvec3 hue(float x, float r) { \n    vec3 v = abs( mod(fract(1.0-x) + vec3(0.0,1.0,2.0) * r, 1.0) * 2.0 - 1.0); \n    return v*v*(3.0-2.0*v);\n}\nvec3 hue(float x) { return hue(x, 0.33333); }\n#endif\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Convert from gamma to linear color space.\nuse: gamma2linear(<float|vec3|vec4> color)\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#if !defined(GAMMA) && !defined(TARGET_MOBILE) && !defined(PLATFORM_RPI) && !defined(PLATFORM_WEBGL)\n#define GAMMA 2.2\n#endif\n\n#ifndef FNC_GAMMA2LINEAR\n#define FNC_GAMMA2LINEAR\nfloat gamma2linear(const in float v) {\n#ifdef GAMMA\n    return pow(v, GAMMA);\n#else\n    // assume gamma 2.0\n    return v * v;\n#endif\n}\n\nvec3 gamma2linear(const in vec3 v) {\n#ifdef GAMMA\n    return pow(v, vec3(GAMMA));\n#else\n    // assume gamma 2.0\n    return v * v;\n#endif\n}\n\nvec4 gamma2linear(const in vec4 v) {\n    return vec4(gamma2linear(v.rgb), v.a);\n}\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Returns a circle-shaped SDF.\nuse: circleSDF(vec2 st[, vec2 center])\noptions:\n    - CENTER_2D: vec2, defaults to vec2(.5)\n    - CIRCLESDF_FNC(POS_UV): function used to calculate the SDF, defaults to GLSL length function, use lengthSq for a different slope\nexamples:\n    - https://raw.githubusercontent.com/patriciogonzalezvivo/lygia_examples/main/draw_shapes.frag\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef CIRCLESDF_FNC\n#define CIRCLESDF_FNC(POS_UV) length(POS_UV)\n#endif\n\n#ifndef FNC_CIRCLESDF\n#define FNC_CIRCLESDF\n\nfloat circleSDF(in vec2 v) {\n#ifdef CENTER_2D\n    v -= CENTER_2D;\n#else\n    v -= 0.5;\n#endif\n    return CIRCLESDF_FNC(v) * 2.0;\n}\n#endif\n\n\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Returns a rectangular SDF\nuse:\n    - rectSDF(<vec2> st [, <vec2|float> size])\n    - rectSDF(<vec2> st [, <vec2|float> size, float radius])\noptions:\n    - CENTER_2D: vec2, defaults to vec2(.5)\nexamples:\n    - https://raw.githubusercontent.com/patriciogonzalezvivo/lygia_examples/main/draw_shapes.frag\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_RECTSDF\n#define FNC_RECTSDF\n\nfloat rectSDF(vec2 p, vec2 b, float r) {\n    vec2 d = abs(p - 0.5) * 4.2 - b + vec2(r);\n    return min(max(d.x, d.y), 0.0) + length(max(d, 0.0)) - r;   \n}\n\nfloat rectSDF(vec2 p, float b, float r) {\n    return rectSDF(p, vec2(b), r);\n}\n\nfloat rectSDF(in vec2 st, in vec2 s) {\n    #ifdef CENTER_2D\n        st -= CENTER_2D;\n        st *= 2.0;\n    #else\n        st = st * 2.0 - 1.0;\n    #endif\n    return max( abs(st.x / s.x),\n                abs(st.y / s.y) );\n}\n\nfloat rectSDF(in vec2 st, in float s) {\n    return rectSDF(st, vec2(s) );\n}\n\nfloat rectSDF(in vec2 st) {\n    return rectSDF(st, vec2(1.0));\n}\n\n#endif\n\n\n\n\n\n/*\ncontributors: Matt DesLauriers\ndescription: Performs a smoothstep using standard derivatives for anti-aliased edges at any level of magnification. From https://github.com/glslify/glsl-aastep\nuse: aastep(<float> threshold, <float> value)\noption:\n    AA_EDGE: in the absence of derivatives you can specify the antialiasing factor\nexamples:\n    - https://raw.githubusercontent.com/eduardfossas/lygia-study-examples/main/draw/aastep.frag\n*/\n\n#ifndef FNC_AASTEP\n#define FNC_AASTEP\n\n#if defined(GL_OES_standard_derivatives)\n#extension GL_OES_standard_derivatives : enable\n#endif\n\nfloat aastep(float threshold, float value) {\n#if !defined(GL_ES) || __VERSION__ >= 300 || defined(GL_OES_standard_derivatives)\n    float afwidth = 0.7 * length(vec2(dFdx(value), dFdy(value)));\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n#elif defined(AA_EDGE)\n    float afwidth = AA_EDGE;\n    return smoothstep(threshold-afwidth, threshold+afwidth, value);\n#else \n    return step(threshold, value);\n#endif\n}\n#endif\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Fill a SDF. From PixelSpiritDeck https://github.com/patriciogonzalezvivo/PixelSpiritDeck\nuse: fill(<float> sdf, <float> size [, <float> edge])\nexamples:\n    - https://raw.githubusercontent.com/patriciogonzalezvivo/lygia_examples/main/draw_shapes.frag\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_FILL\n#define FNC_FILL\nfloat fill(float x, float size, float edge) {\n    return 1.0 - smoothstep(size - edge, size + edge, x);\n}\n\nfloat fill(float x, float size) {\n    return 1.0 - aastep(size, x);\n}\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Fill a stroke in a SDF. From PixelSpiritDeck https://github.com/patriciogonzalezvivo/PixelSpiritDeck\nuse: stroke(<float> sdf, <float> size, <float> width [, <float> edge])\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_STROKE\n#define FNC_STROKE\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: clamp a value between 0 and 1\nuse: <float|vec2|vec3|vec4> saturation(<float|vec2|vec3|vec4> value)\nexamples:\n    - https://raw.githubusercontent.com/patriciogonzalezvivo/lygia_examples/main/math_functions.frag\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#if !defined(FNC_SATURATE) && !defined(saturate)\n#define FNC_SATURATE\n#define saturate(V) clamp(V, 0.0, 1.0)\n#endif\n\n\nfloat stroke(float x, float size, float w) {\n    float d = aastep(size, x + w * 0.5) - aastep(size, x - w * 0.5);\n    return saturate(d);\n}\n\nfloat stroke(float x, float size, float w, float edge) {\n    float d = smoothstep(size - edge, size + edge, x + w * 0.5) - smoothstep(size - edge, size + edge, x - w * 0.5);\n    return saturate(d);\n}\n\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Draw a rectangel filled or not.\nuse: rect(<vec2> st, <vec2> size [, <float> width])\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_RECT\n#define FNC_RECT\n\nfloat rect(vec2 st, vec2 size, float strokeWidth) {\n    return stroke(rectSDF(st, size), 1.0, strokeWidth);\n}\n\nfloat rect(vec2 st, float size, float strokeWidth) {\n    return stroke(rectSDF(st, vec2(size)), 1.0, strokeWidth);\n}\n\nfloat rect(vec2 st, vec2 size) {\n    return fill(rectSDF(st, size), 1.0);\n}\n\nfloat rect(vec2 st, float size) {\n    return fill(rectSDF(st, vec2(size)), 1.0);\n}\n\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: some useful math constants\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n#ifndef EIGHTH_PI\n#define EIGHTH_PI 0.39269908169\n#endif\n#ifndef QTR_PI\n#define QTR_PI 0.78539816339\n#endif\n#ifndef HALF_PI\n#define HALF_PI 1.5707963267948966192313216916398\n#endif\n#ifndef PI\n#define PI 3.1415926535897932384626433832795\n#endif\n#ifndef TWO_PI\n#define TWO_PI 6.2831853071795864769252867665590\n#endif\n#ifndef TAU\n#define TAU 6.2831853071795864769252867665590\n#endif\n#ifndef INV_PI\n#define INV_PI 0.31830988618379067153776752674503\n#endif\n#ifndef INV_SQRT_TAU\n#define INV_SQRT_TAU 0.39894228040143267793994605993439  // 1.0/SQRT_TAU\n#endif\n#ifndef SQRT_HALF_PI\n#define SQRT_HALF_PI 1.25331413732\n#endif\n#ifndef PHI\n#define PHI 1.618033988749894848204586834\n#endif\n#ifndef EPSILON\n#define EPSILON 0.0000001\n#endif\n#ifndef GOLDEN_RATIO\n#define GOLDEN_RATIO 1.6180339887\n#endif\n#ifndef GOLDEN_RATIO_CONJUGATE \n#define GOLDEN_RATIO_CONJUGATE 0.61803398875\n#endif\n#ifndef GOLDEN_ANGLE // (3.-sqrt(5.0))*PI radians\n#define GOLDEN_ANGLE 2.39996323\n#endif\n#ifndef DEG2RAD\n#define DEG2RAD (PI / 180.0)\n#endif\n#ifndef RAD2DEG\n#define RAD2DEG (180.0 / PI)\n#endif\n\n\n\n// Stars deps\n\n/*\ncontributors: Mercury\ndescription: |\n    Two dimensional modulus, returns the remainder of a division of two vectors.\n    Found at in Mercury\'s library https://mercury.sexy/hg_sdf/\nuse: <vec2> mod2(<vec2> x, <vec2> size)\n*/\n\n#ifndef FNC_MOD2\n#define FNC_MOD2\nvec2 mod2(inout vec2 p, float s) {\n    vec2 c = floor((p + s*0.5)/s);\n    p = mod(p + s*0.5,s) - s*0.5;\n    return c;\n}\n\nvec2 mod2(inout vec2 p, vec2 s) {\n    vec2 c = floor((p + s*0.5)/s);\n    p = mod(p + s*0.5,s) - s*0.5;\n    return c;\n}\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: returns a 3x3 rotation matrix\nuse: <mat3> rotate3dX(<float> radians)\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_ROTATE3DX\n#define FNC_ROTATE3DX\nmat3 rotate3dX(const in float r){\n    float c = cos(r);\n    float s = sin(r);\n    return mat3(vec3(1.0,0.0,0.0),\n                vec3(0.0,c,s),\n                vec3(0.0,-s,c));\n}\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: returns a 3x3 rotation matrix\nuse: <mat3> rotate3dZ(<float> radians)\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_ROTATE3DZ\n#define FNC_ROTATE3DZ\nmat3 rotate3dZ(const in float r){\n    float c = cos(r);\n    float s = sin(r);\n    return mat3(vec3(c,s,0.),\n                vec3(-s,c,0.),\n                vec3(0.,0.,1.));\n}\n#endif\n\n\n\n/*\ncontributors: [Ivan Dianov, Kathy McGuiness]\ndescription: cartesian to polar transformation.\nuse: <vec2|vec3> cart2polar(<vec2|vec3> st)\n*/\n\n#ifndef FNC_CART2POLAR\n#define FNC_CART2POLAR\n\nvec2 cart2polar(in vec2 st) {\n    return vec2(atan(st.y, st.x), length(st));\n}\n\n// https://mathworld.wolfram.com/SphericalCoordinates.html\nvec3 cart2polar( in vec3 st ) {\n    float r = length(st);\n    float phi = acos(st.z/r);\n    float theta = atan(st.y, st.x);\n    return vec3(r, phi, theta);\n}\n\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Blackbody in kelvin to RGB. Range between 0.0 and 40000.0 Kelvin\nuse: <vec3> k2rgb(<float> wavelength)\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_K2RGB\n#define FNC_K2RGB\n\nvec3 k2rgb(const in float t) {\n    float p = pow(t, -1.5);\n    float l = log(t);\n    vec3 color = vec3(\n        220000.0 * p + 0.5804,\n        0.3923 * l - 2.4431,\n        0.7615 * l - 5.681\n    );\n\n    if (t > 6500.0) \n        color.g = 138039.0 * p + 0.738;\n\n    color = saturate(color);\n    if (t < 1000.0) \n        color *= t/1000.0;\n\n    return color;\n}\n\n// vec3 k2rgb(float k) {\n//     vec3 result = vec3(0.0);\n//     result += pow(k, 5.0)*vec3(0.000000000003,0.000000000005,0.000000000002);\n//     result += pow(k, 4.0)*vec3(-0.000000003171,-0.000000006209,-0.000000003218);\n//     result += pow(k, 3.0)*vec3(0.000001228482,0.000002663965,0.000001592322);\n//     result += pow(k, 2.0)*vec3(-0.000191890124,-0.000514748678,-0.000373276480);\n//     result += pow(k, 1.0)*vec3(0.007157629359,0.041633483053,0.040925109898);\n//     result += pow(k, 0.0)*vec3(0.949884505573,-0.338527499316,-0.649683924890);\n//     return result;\n// }\n\n// vec3 k2rgb(float k) {\n//     vec3 retColor = vec3(0.0);\n\n//     k = clamp(k, 1000.0, 40000.0) / 100.0;\n//     if (k <= 66.0) {\n//         retColor.r = 1.0;\n//         retColor.g = saturate(0.39008157876901960784 * log(k) - 0.63184144378862745098);\n//     }\n//     else {\n//         float t = k - 60.0;\n//         retColor.r = saturate(1.29293618606274509804 * pow(t, -0.1332047592));\n//         retColor.g = saturate(1.12989086089529411765 * pow(t, -0.0755148492));\n//     }\n    \n//     if (k >= 66.0)\n//         retColor.b = 1.0;\n//     else if(k <= 19.0)\n//         retColor.b = 0.0;\n//     else\n//         retColor.b = saturate(0.54320678911019607843 * log(k - 10.0) - 1.19625408914);\n\n//     return retColor;\n// }\n\n#endif\n\n\n/*\ncontributors: ["Patricio Gonzalez Vivo", "David Hoskins", "Inigo Quilez"]\ndescription: Pass a value and get some random normalize value between 0 and 1\nuse: float random[2|3](<float|vec2|vec3> value)\noptions:\n    - RANDOM_HIGHER_RANGE: for working with a range over 0 and 1\n    - RANDOM_SINLESS: Use sin-less random, which tolerates bigger values before producing pattern. From https://www.shadertoy.com/view/4djSRW\n    - RANDOM_SCALE: by default this scale if for number with a big range. For producing good random between 0 and 1 use bigger range\nexamples:\n    - /shaders/generative_random.frag\nlicense:\n    - MIT License (MIT) Copyright 2014, David Hoskins\n*/\n\n#ifndef RANDOM_SCALE\n#ifdef RANDOM_HIGHER_RANGE\n#define RANDOM_SCALE vec4(.1031, .1030, .0973, .1099)\n#else\n#define RANDOM_SCALE vec4(443.897, 441.423, .0973, .1099)\n#endif\n#endif\n\n#ifndef FNC_RANDOM\n#define FNC_RANDOM\nfloat random(in float x) {\n#ifdef RANDOM_SINLESS\n    x = fract(x * RANDOM_SCALE.x);\n    x *= x + 33.33;\n    x *= x + x;\n    return fract(x);\n#else\n    return fract(sin(x) * 43758.5453);\n#endif\n}\n\nfloat random(in vec2 st) {\n#ifdef RANDOM_SINLESS\n    vec3 p3  = fract(vec3(st.xyx) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 33.33);\n    return fract((p3.x + p3.y) * p3.z);\n#else\n    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453);\n#endif\n}\n\nfloat random(in vec3 pos) {\n#ifdef RANDOM_SINLESS\n    pos  = fract(pos * RANDOM_SCALE.xyz);\n    pos += dot(pos, pos.zyx + 31.32);\n    return fract((pos.x + pos.y) * pos.z);\n#else\n    return fract(sin(dot(pos.xyz, vec3(70.9898, 78.233, 32.4355))) * 43758.5453123);\n#endif\n}\n\nfloat random(in vec4 pos) {\n#ifdef RANDOM_SINLESS\n    pos = fract(pos * RANDOM_SCALE);\n    pos += dot(pos, pos.wzxy + 33.33);\n    return fract((pos.x + pos.y) * (pos.z + pos.w));\n#else\n    float dot_product = dot(pos, vec4(12.9898,78.233,45.164,94.673));\n    return fract(sin(dot_product) * 43758.5453);\n#endif\n}\n\nvec2 random2(float p) {\n    vec3 p3 = fract(vec3(p) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec2 random2(vec2 p) {\n    vec3 p3 = fract(p.xyx * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec2 random2(vec3 p3) {\n    p3 = fract(p3 * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xx + p3.yz) * p3.zy);\n}\n\nvec3 random3(float p) {\n    vec3 p3 = fract(vec3(p) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.xxy + p3.yzz) * p3.zyx); \n}\n\nvec3 random3(vec2 p) {\n    vec3 p3 = fract(vec3(p.xyx) * RANDOM_SCALE.xyz);\n    p3 += dot(p3, p3.yxz + 19.19);\n    return fract((p3.xxy + p3.yzz) * p3.zyx);\n}\n\nvec3 random3(vec3 p) {\n    p = fract(p * RANDOM_SCALE.xyz);\n    p += dot(p, p.yxz + 19.19);\n    return fract((p.xxy + p.yzz) * p.zyx);\n}\n\nvec4 random4(float p) {\n    vec4 p4 = fract(p * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);   \n}\n\nvec4 random4(vec2 p) {\n    vec4 p4 = fract(p.xyxy * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nvec4 random4(vec3 p) {\n    vec4 p4 = fract(p.xyzx * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n\nvec4 random4(vec4 p4) {\n    p4 = fract(p4  * RANDOM_SCALE);\n    p4 += dot(p4, p4.wzxy + 19.19);\n    return fract((p4.xxyz + p4.yzzw) * p4.zywx);\n}\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Generic Ray Structure\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef STR_RAY\n#define STR_RAY\nstruct Ray {\n    vec3 origin;\n    vec3 direction;\n};\n#endif\n\n\n\n#ifndef FNC_RAYLEIGH\n#define FNC_RAYLEIGH\n\n// Rayleigh phase\nfloat rayleigh(const in float mu) {\n    return 3. * (1. + mu*mu) / (16. * PI);\n}\n\n#endif\n\n\n\n// Henyey-Greenstein phase function factor [-1, 1]\n// represents the average cosine of the scattered directions\n// 0 is isotropic scattering\n// > 1 is forward scattering, < 1 is backwards\n#ifndef HENYEYGREENSTEIN_SCATTERING\n#define HENYEYGREENSTEIN_SCATTERING 0.76\n#endif\n\n#ifndef FNC_HENYEYGREENSTEIN\n#define FNC_HENYEYGREENSTEIN\nfloat henyeyGreenstein(const in float mu) {\n    return max(0.0, (1.0 - HENYEYGREENSTEIN_SCATTERING*HENYEYGREENSTEIN_SCATTERING) / ((4. + PI) * pow(1.0 + HENYEYGREENSTEIN_SCATTERING*HENYEYGREENSTEIN_SCATTERING - 2.0 * HENYEYGREENSTEIN_SCATTERING * mu, 1.5)));\n}\n\nfloat henyeyGreenstein(float mu, float g) {\n    float gg = g * g;\n    return (1.0 / (4.0 * PI)) * ((1.0 - gg) / pow(1.0 + gg - 2.0 * g * mu, 1.5));\n}\n\nfloat henyeyGreenstein(float mu, float g, float dual_lobe_weight) {\n    return mix(henyeyGreenstein( mu, -g), henyeyGreenstein(mu, g), dual_lobe_weight);\n}\n#endif\n\n\n/*\ncontributor: Patricio Gonzalez Vivo\ndescription: |\n    Rayleigh and Mie scattering atmosphere system. \n    Based on:\n    - ["Accurate Atmospheric Scattering" from GPU Gems2](https://developer.nvidia.com/gpugems/GPUGems2/gpugems2_chapter16.html)\n    - [Alan Zucconi\'s Atmospheric Scattering articles](https://www.alanzucconi.com/2017/10/10/atmospheric-scattering-6/)\n    - [Dimas Leenman atmosphere.glsl](https://github.com/Dimev/atmospheric-scattering-explained)\n    - [Simulating the Colors of the Sky](https://www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky/simulating-colors-of-the-sky.html)\n    - [License CC0: Stars and galaxy by mrange](https://www.shadertoy.com/view/stBcW1)\nuse: <vec3> atmosphere(<vec3> eye_dir, <vec3> sun_dir)\nOPTIONS:\n    ATMOSPHERE_ORIGIN: Default vec3(0.0)\n    ATMOSPHERE_SUN_POWER: sun power. Default 20.0\n    ATMOSPHERE_LIGHT_SAMPLES: Default 8 \n    ATMOSPHERE_SAMPLES: Default 16\n    ATMOSPHERE_GROUND: Example vec3( 0.37, 0.35, 0.34 )\n    ATMOSPHERE_STARS_LAYERS: Example 3\n    ATMOSPHERE_STARS_ELEVATION: Example u_time * 0.01\n    ATMOSPHERE_STARS_AZIMUTH: Example u_time * 0.05\nexamples:\n    - /shaders/lighting_atmosphere.frag\n*/\n\n#ifndef ATMOSPHERE_ORIGIN\n#define ATMOSPHERE_ORIGIN vec3(0.0)\n#endif\n\n#ifndef ATMOSPHERE_SUN_POWER\n#define ATMOSPHERE_SUN_POWER 20.0\n#endif\n\n#ifndef ATMOSPHERE_RAY\n#define ATMOSPHERE_RAY vec3(55e-7, 13e-6, 22e-6)\n#endif\n\n#ifndef ATMOSPHERE_MIE\n#define ATMOSPHERE_MIE vec3(21e-6)\n#endif\n\n#ifndef ATMOSPHERE_LIGHT_SAMPLES\n#define ATMOSPHERE_LIGHT_SAMPLES 8\n#endif\n\n#ifndef ATMOSPHERE_SAMPLES\n#define ATMOSPHERE_SAMPLES 16\n#endif\n\n#ifndef FNC_ATMOSPHERE\n#define FNC_ATMOSPHERE\n\nbool atmosphere_intersect(Ray ray, inout float t0, inout float t1) {\n    vec3 L = ATMOSPHERE_ORIGIN - ray.origin; \n    float DT = dot(L, ray.direction);\n    float D2 = dot(L, L) - DT * DT;\n\n    const float R2 = 412164e8;\n    if (D2 > R2) \n        return false;\n\n    float AT = sqrt(R2 - D2);\n    t0 = DT - AT;\n    t1 = DT + AT;\n    return true;\n}\n\nvec3 atmosphere_pos(Ray ray, float dist, float ds) {\n    return ray.origin + ray.direction * (dist + ds * 0.5);\n}\n\nfloat atmosphere_height(Ray ray, float dist,  float ds, inout vec2 density) {\n    vec3 p = atmosphere_pos(ray, dist, ds);\n    float h = length(p) - 6371e3;\n\n    #ifdef ATMOSPHERE_GROUND\n    if (h <= 0.0)\n        return 0.0;\n    #endif\n\n    density += exp(-h * vec2(125e-6, 833e-6)) * ds; // Rayleigh\n    return h;\n}\n\nbool atmosphere_light(Ray ray, inout vec2 depth) {\n    float t0 = 0.0;     // Atmosphere entry point \n    float t1 = 99999.0; // Atmosphere exit point\n\n    #ifdef ATMOSPHERE_GROUND\n    if (!atmosphere_intersect(ray, t0, t1))\n        return false;\n    #endif\n\n    float dist = 0.;\n    float dstep = t1 / float(ATMOSPHERE_LIGHT_SAMPLES);\n    for (int i = 0; i < ATMOSPHERE_LIGHT_SAMPLES; i++) {\n        if (atmosphere_height(ray, dist,  dstep, depth) <= 0.0)\n            return false;\n\n        dist += dstep;\n    }\n\n    return true;\n}\n\nvec3 atmosphere(Ray ray, vec3 sun_dir) {\n    float t0 = 0.0;\n    float t1 = 99999.0;\n\n    #ifdef ATMOSPHERE_GROUND\n    if (!atmosphere_intersect(ray, t0, t1))\n        return vec3(0.0);\n    #endif\n\n    float dstep = t1 / float(ATMOSPHERE_SAMPLES);\n    vec2 depth = vec2(0.0);\n\n    vec3 sumR = vec3(0.0, 0.0, 0.0);\n    vec3 sumM = vec3(0.0, 0.0, 0.0);\n    float dist = 0.0;\n    for (int i = 0; i < ATMOSPHERE_SAMPLES; i++) {\n        vec2 density = vec2(0.);\n\n        #ifdef ATMOSPHERE_GROUND\n        if (atmosphere_height(ray, dist, dstep, density) <= 0.0)\n            return ATMOSPHERE_GROUND * sun_dir.y;\n        #else\n            atmosphere_height(ray, dist, dstep, density);\n\n        #endif\n\n        depth += density;\n\n        vec2 light = vec2(0.);\n        if ( atmosphere_light(Ray(atmosphere_pos(ray, dist, dstep), sun_dir), light) ) {\n            vec3 attn = exp(-ATMOSPHERE_RAY * (depth.x + light.x)\n                            -ATMOSPHERE_MIE * (depth.y + light.y));\n            sumR += density.x * attn;\n            sumM += density.y * attn;\n        }\n\n        dist += dstep;\n    }\n\n    float mu = dot(ray.direction, sun_dir);\n    sumR *= rayleigh(mu) * ATMOSPHERE_RAY;\n    sumM *= henyeyGreenstein(mu) * ATMOSPHERE_MIE;\n    vec3 color = ATMOSPHERE_SUN_POWER * (sumR + sumM);\n\n    // Draw stars\n    #ifdef ATMOSPHERE_STARS_LAYERS\n    const float m = float(ATMOSPHERE_STARS_LAYERS);\n    float hh = 1.0-saturate(sun_dir.y);\n    hh *= hh;\n    hh *= hh * hh * hh;\n    vec3 dir = ray.direction;\n    #ifdef ATMOSPHERE_GROUND\n    hh *= step(0.0, dir.y);\n    #endif\n\n    #ifdef ATMOSPHERE_STARS_ELEVATION\n    dir = rotate3dX(ATMOSPHERE_STARS_ELEVATION) * dir;\n    #endif\n    #ifdef ATMOSPHERE_STARS_AZIMUTH\n    dir = rotate3dZ(ATMOSPHERE_STARS_AZIMUTH) * dir;\n    #endif\n    vec2 sp = cart2polar(dir.xzy).yz;\n    for (float i = 0.0; i < m; ++i) {\n        vec2 pp = sp + 0.5 * i;\n        float s = i / (m-1.0);\n        float dim = mix(0.05, 0.003, s) * PI;\n        vec2 np = mod2(pp, dim);\n        vec2 h = random2(np + 127.0 + i);\n        vec2 o = -1.0+2.0*h;\n        float y = sin(sp.x);\n        pp += o * dim * 0.5;\n        pp.y *= y;\n        float l = length(pp);\n    \n        float h1 = fract(h.x * 1667.0);\n        float h2 = fract(h.x * 1887.0);\n        float h3 = fract(h.x * 2997.0);\n\n        vec3 scol = mix(8.0 * h2, 0.25 * h2 * h2, s) * k2rgb(mix(3000.0, 22000.0, h1 * h1));\n        vec3 ccol = color + exp(-(mix(6000.0, 2000.0, hh) / mix(2.0, 0.25, s)) * max(l-0.001, 0.0)) * scol * hh;\n        color = h3 < y ? ccol : color;\n    }\n\n    #endif\n\n    return color;\n}\n\nvec3 atmosphere(vec3 eye_dir, vec3 sun_dir) {\n    Ray ray = Ray(vec3(0., 6371e3 + 1.0, 0.), eye_dir);\n    return atmosphere(ray, sun_dir);\n}\n\n#endif\n\n\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: power of 5\nuse: <float|vec2|vec3|vec4> pow5(<float|vec2|vec3|vec4> v)\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_POW5\n#define FNC_POW5\n\nfloat pow5(const in float v) {\n    float v2 = v * v;\n    return v2 * v2 * v;\n}\n\nvec2 pow5(const in vec2 v) {\n    vec2 v2 = v * v;\n    return v2 * v2 * v;\n}\n\nvec3 pow5(const in vec3 v) {\n    vec3 v2 = v * v;\n    return v2 * v2 * v;\n}\n\nvec4 pow5(const in vec4 v) {\n    vec4 v2 = v * v;\n    return v2 * v2 * v;\n}\n\n#endif\n\n\n\n#ifndef FNC_SCHLICK\n#define FNC_SCHLICK\n\n// Schlick 1994, "An Inexpensive BRDF Model for Physically-Based Rendering"\nvec3 schlick(const in vec3 f0, const in float f90, const in float VoH) {\n    float f = pow5(1.0 - VoH);\n    return f + f0 * (f90 - f);\n}\n\nvec3 schlick(const in vec3 f0, const in vec3 f90, const in float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\nfloat schlick(const in float f0, const in float f90, const in float VoH) {\n    return f0 + (f90 - f0) * pow5(1.0 - VoH);\n}\n\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Resolve fresnel coefficient\nuse:\n    - <float|vec3> fresnel(const <float|vec3> f0, <float> NoV)\n    - <float|vec3> fresnel(const <float|vec3> f0, <float> NoV, float roughness)\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_FRESNEL\n#define FNC_FRESNEL\n\nvec3 fresnel(const in vec3 f0, vec3 normal, vec3 view) {\n   return schlick(f0, 1.0, dot(view, normal));\n}\n\nvec3 fresnel(const in vec3 f0, const in float NoV) {\n#if defined(TARGET_MOBILE) || defined(PLATFORM_RPI)\n    return schlick(f0, 1.0, NoV);\n#else\n    float f90 = saturate(dot(f0, vec3(50.0 * 0.33)));\n    return schlick(f0, f90, NoV);\n#endif\n}\n\nfloat fresnel(const in float f0, const in float NoV) {\n    return schlick(f0, 1.0, NoV);\n}\n\n// Roughness-adjusted fresnel function to attenuate high speculars at glancing angles\n// Very useful when used with filtered environment maps\n// See https://seblagarde.wordpress.com/2011/08/17/hello-world/\nvec3 fresnel(vec3 f0, float NoV, float roughness) {\n    return f0 + (max(vec3(1.0 - roughness), f0) - f0) * pow5(1.0 - NoV);\n}\n\n#endif\n\n\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: 3D vector to equirect 2D projection\nuse: <vec2> xyz2equirect(<vec2> d)\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_XYZ2EQUIRECT\n#define FNC_XYZ2EQUIRECT\nvec2 xyz2equirect(vec3 d) {\n    return vec2(atan(d.z, d.x) + PI, acos(-d.y)) / vec2(2.0 * PI, PI);\n}\n#endif\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: It defines the default sampler type and function for the shader based on the version of GLSL.\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n#ifndef SAMPLER_FNC\n#if __VERSION__ >= 300\n#define SAMPLER_FNC(TEX, UV) texture(TEX, UV)\n#else\n#define SAMPLER_FNC(TEX, UV) texture2D(TEX, UV)\n#endif\n#endif\n\n#ifndef SAMPLER_TYPE\n#define SAMPLER_TYPE sampler2D\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Convert from linear to gamma color space.\nuse: linear2gamma(<float|vec3|vec4> color)\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#if !defined(GAMMA) && !defined(TARGET_MOBILE) && !defined(PLATFORM_RPI) && !defined(PLATFORM_WEBGL)\n#define GAMMA 2.2\n#endif\n\n#ifndef FNC_LINEAR2GAMMA\n#define FNC_LINEAR2GAMMA\nvec3 linear2gamma(const in vec3 v) {\n#ifdef GAMMA\n    return pow(v, vec3(1.0/GAMMA));\n#else\n    // assume gamma 2.0\n    return sqrt(v);\n#endif\n}\n\nvec4 linear2gamma(const in vec4 v) {\n    return vec4(linear2gamma(v.rgb), v.a);\n}\n\nfloat linear2gamma(const in float v) {\n#ifdef GAMMA\n    return pow(v, 1.0/GAMMA);\n#else\n    // assume gamma 2.0\n    return sqrt(v);\n#endif\n}\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Convert from gamma to linear color space.\nuse: gamma2linear(<float|vec3|vec4> color)\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#if !defined(GAMMA) && !defined(TARGET_MOBILE) && !defined(PLATFORM_RPI) && !defined(PLATFORM_WEBGL)\n#define GAMMA 2.2\n#endif\n\n#ifndef FNC_GAMMA2LINEAR\n#define FNC_GAMMA2LINEAR\nfloat gamma2linear(const in float v) {\n#ifdef GAMMA\n    return pow(v, GAMMA);\n#else\n    // assume gamma 2.0\n    return v * v;\n#endif\n}\n\nvec3 gamma2linear(const in vec3 v) {\n#ifdef GAMMA\n    return pow(v, vec3(GAMMA));\n#else\n    // assume gamma 2.0\n    return v * v;\n#endif\n}\n\nvec4 gamma2linear(const in vec4 v) {\n    return vec4(gamma2linear(v.rgb), v.a);\n}\n#endif\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: sample an equirect texture as it was a cubemap\nuse: sampleEquirect(<SAMPLER_TYPE> texture, <vec3> dir)\noptions:\n    - SAMPLER_FNC(TEX, UV): optional depending the target version of GLSL (texture2D(...) or texture(...))\n    - SAMPLEEQUIRECT_ITERATIONS: null\n    - SAMPLEEQUIRECT_FLIP_Y\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_SAMPLEEQUIRECT\n#define FNC_SAMPLEEQUIRECT\nvec4 sampleEquirect(SAMPLER_TYPE tex, vec3 dir) { \n    vec2 st = xyz2equirect(dir);\n    #ifdef SAMPLEEQUIRECT_FLIP_Y\n    st.y = 1.0-st.y;\n    #endif\n    return SAMPLER_FNC(tex, st); \n}\n\nvec4 sampleEquirect(SAMPLER_TYPE tex, vec3 dir, float lod) { \n    \n    #if defined(SAMPLEEQUIRECT_ITERATIONS)\n    vec4 color = vec4(0.0);\n    vec2 st = xyz2equirect(dir);\n    #ifdef SAMPLEEQUIRECT_FLIP_Y\n        st.y = 1.0-st.y;\n    #endif\n\n    vec2 r = vec2(1.0+lod);\n    const float f = 1.0 / (1.001 - 0.75);\n    mat2 rot = mat2( cos(GOLDEN_ANGLE), sin(GOLDEN_ANGLE), \n                    -sin(GOLDEN_ANGLE), cos(GOLDEN_ANGLE));\n    vec2 st2 = vec2( dot(st + st - r, vec2(.0002,-0.001)), 0.0 );\n\n    float counter = 0.0;\n    #ifdef PLATFORM_WEBGL\n    for (float i = 0.0; i < float(SAMPLEEQUIRECT_ITERATIONS); i++) {\n    #else\n    for (float i = 0.0; i < float(SAMPLEEQUIRECT_ITERATIONS); i += 2.0/i) {\n    #endif\n        st2 *= rot;\n        color += gamma2linear( SAMPLER_FNC(tex, st + st2 * i / vec2(r.x * 2.0, r.y))) * f;\n        counter++;\n    }\n    return linear2gamma(color / counter);\n\n    #else\n\n    dir += srandom3( dir ) * 0.01 * lod;\n    vec2 st = xyz2equirect(dir);\n    #ifdef SAMPLEEQUIRECT_FLIP_Y\n        st.y = 1.0-st.y;\n    #endif\n    return SAMPLER_FNC(tex, st);\n\n    #endif\n}\n\n\n#endif\n\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Get material BaseColor from GlslViewer\'s defines https://github.com/patriciogonzalezvivo/glslViewer/wiki/GlslViewer-DEFINES#material-defines\nuse: vec4 materialAlbedo()\noptions:\n    - SAMPLER_FNC(TEX, UV): optional depending the target version of GLSL (texture2D(...) or texture(...))\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_MATERIAL_ALBEDO\n#define FNC_MATERIAL_ALBEDO\n\n#ifdef MATERIAL_BASECOLORMAP\nuniform SAMPLER_TYPE MATERIAL_BASECOLORMAP;\n#endif\n\n#ifdef MATERIAL_ALBEDOMAP\nuniform SAMPLER_TYPE MATERIAL_ALBEDOMAP;\n#endif\n\nvec4 materialAlbedo() {\n    vec4 albedo = vec4(0.5, 0.5, 0.5, 1.0);\n    \n#if defined(MATERIAL_BASECOLORMAP) && defined(MODEL_VERTEX_TEXCOORD)\n    vec2 uv = v_texcoord.xy;\n    #if defined(MATERIAL_BASECOLORMAP_OFFSET)\n    uv += (MATERIAL_BASECOLORMAP_OFFSET).xy;\n    #endif\n    #if defined(MATERIAL_BASECOLORMAP_SCALE)\n    uv *= (MATERIAL_BASECOLORMAP_SCALE).xy;\n    #endif\n    albedo = gamma2linear( SAMPLER_FNC(MATERIAL_BASECOLORMAP, uv) );\n\n#elif defined(MATERIAL_ALBEDOMAP) && defined(MODEL_VERTEX_TEXCOORD)\n    vec2 uv = v_texcoord.xy;\n    #if defined(MATERIAL_ALBEDOMAP_OFFSET)\n    uv += (MATERIAL_ALBEDOMAP_OFFSET).xy;\n    #endif\n    #if defined(MATERIAL_ALBEDOMAP_SCALE)\n    uv *= (MATERIAL_ALBEDOMAP_SCALE).xy;\n    #endif\n    albedo = gamma2linear( SAMPLER_FNC(MATERIAL_ALBEDOMAP, uv) );\n\n#elif defined(MATERIAL_BASECOLOR)\n    albedo = MATERIAL_BASECOLOR;\n\n#elif defined(MATERIAL_ALBEDO)\n    albedo = MATERIAL_ALBEDO;\n\n#endif\n\n#if defined(MODEL_VERTEX_COLOR)\n    albedo *= v_color;\n#endif\n\n    return albedo;\n}\n\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Get material specular property from GlslViewer\'s defines https://github.com/patriciogonzalezvivo/glslViewer/wiki/GlslViewer-DEFINES#material-defines\nuse: vec4 materialMetallic()\noptions:\n    - SAMPLER_FNC(TEX, UV): optional depending the target version of GLSL (texture2D(...) or texture(...))\n    - MATERIAL_SPECULARMAP\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_MATERIAL_SPECULAR\n#define FNC_MATERIAL_SPECULAR\n\n#ifdef MATERIAL_SPECULARMAP\nuniform SAMPLER_TYPE MATERIAL_SPECULARMAP;\n#endif\n\nvec3 materialSpecular() {\n    vec3 spec = vec3(0.04);\n#if defined(MATERIAL_SPECULARMAP) && defined(MODEL_VERTEX_TEXCOORD)\n    vec2 uv = v_texcoord.xy;\n    #if defined(MATERIAL_SPECULARMAP_OFFSET)\n    uv += (MATERIAL_SPECULARMAP_OFFSET).xy;\n    #endif\n    #if defined(MATERIAL_SPECULARMAP_SCALE)\n    uv *= (MATERIAL_SPECULARMAP_SCALE).xy;\n    #endif\n    spec = SAMPLER_FNC(MATERIAL_SPECULARMAP, uv).rgb;\n#elif defined(MATERIAL_SPECULAR)\n    spec = MATERIAL_SPECULAR;\n#endif\n    return spec;\n}\n\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Get material emissive property from GlslViewer\'s defines https://github.com/patriciogonzalezvivo/glslViewer/wiki/GlslViewer-DEFINES#material-defines\nuse: vec4 materialEmissive()\noptions:\n    - SAMPLER_FNC(TEX, UV): optional depending the target version of GLSL (texture2D(...) or texture(...))\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_MATERIAL_EMISSIVE\n#define FNC_MATERIAL_EMISSIVE\n\n#ifdef MATERIAL_EMISSIVEMAP\nuniform SAMPLER_TYPE MATERIAL_EMISSIVEMAP;\n#endif\n\nvec3 materialEmissive() {\n    vec3 emission = vec3(0.0);\n\n#if defined(MATERIAL_EMISSIVEMAP) && defined(MODEL_VERTEX_TEXCOORD)\n    vec2 uv = v_texcoord.xy;\n    #if defined(MATERIAL_EMISSIVEMAP_OFFSET)\n    uv += (MATERIAL_EMISSIVEMAP_OFFSET).xy;\n    #endif\n    #if defined(MATERIAL_EMISSIVEMAP_SCALE)\n    uv *= (MATERIAL_EMISSIVEMAP_SCALE).xy;\n    #endif\n    emission = gamma2linear( SAMPLER_FNC(MATERIAL_EMISSIVEMAP, uv) ).rgb;\n\n#elif defined(MATERIAL_EMISSIVE)\n    emission = MATERIAL_EMISSIVE;\n#endif\n\n    return emission;\n}\n\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Get material normal property from GlslViewer\'s defines https://github.com/patriciogonzalezvivo/glslViewer/wiki/GlslViewer-DEFINES#material-defines\nuse: vec4 materialOcclusion()\noptions:\n    - SAMPLER_FNC(TEX, UV): optional depending the target version of GLSL (texture2D(...) or texture(...))\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_MATERIAL_OCCLUSION\n#define FNC_MATERIAL_OCCLUSION\n\n#ifdef MATERIAL_OCCLUSIONMAP\nuniform SAMPLER_TYPE MATERIAL_OCCLUSIONMAP;\n#endif\n\n#if defined(MATERIAL_OCCLUSIONROUGHNESSMETALLICMAP) && !defined(MATERIAL_OCCLUSIONROUGHNESSMETALLICMAP_UNIFORM)\n#define MATERIAL_OCCLUSIONROUGHNESSMETALLICMAP_UNIFORM\nuniform SAMPLER_TYPE MATERIAL_OCCLUSIONROUGHNESSMETALLICMAP;\n#endif\n\nfloat materialOcclusion() {\n    float occlusion = 1.0;\n\n#if defined(MATERIAL_OCCLUSIONMAP) && defined(MODEL_VERTEX_TEXCOORD)\n    vec2 uv = v_texcoord.xy;\n    occlusion = SAMPLER_FNC(MATERIAL_OCCLUSIONMAP, uv).r;\n#elif defined(MATERIAL_OCCLUSIONROUGHNESSMETALLICMAP) && defined(MODEL_VERTEX_TEXCOORD)\n    vec2 uv = v_texcoord.xy;\n    occlusion = SAMPLER_FNC(MATERIAL_OCCLUSIONROUGHNESSMETALLICMAP, uv).r;\n#endif\n\n#if defined(MATERIAL_OCCLUSIONMAP_STRENGTH)\n    occlusion *= MATERIAL_OCCLUSIONMAP_STRENGTH;\n#endif\n\n    return occlusion;\n}\n\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Get material normal property from GlslViewer\'s defines https://github.com/patriciogonzalezvivo/glslViewer/wiki/GlslViewer-DEFINES#material-defines\nuse: vec4 materialNormal()\noptions:\n    - SAMPLER_FNC(TEX, UV): optional depending the target version of GLSL (texture2D(...) or texture(...))\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_MATERIAL_NORMAL\n#define FNC_MATERIAL_NORMAL\n\n#ifdef MATERIAL_NORMALMAP\nuniform SAMPLER_TYPE MATERIAL_NORMALMAP;\n#endif\n\n#ifdef MATERIAL_BUMPMAP_NORMALMAP\nuniform SAMPLER_TYPE MATERIAL_BUMPMAP_NORMALMAP;\n#endif\n\nvec3 materialNormal() {\n    vec3 normal = vec3(0.0, 0.0, 1.0);\n\n#ifdef MODEL_VERTEX_NORMAL\n    normal = v_normal;\n\n    #if defined(MODEL_VERTEX_TANGENT) && defined(MODEL_VERTEX_TEXCOORD) && defined(MATERIAL_NORMALMAP) \n    vec2 uv = v_texcoord.xy;\n        #if defined(MATERIAL_NORMALMAP_OFFSET)\n    uv += (MATERIAL_NORMALMAP_OFFSET).xy;\n        #endif\n        #if defined(MATERIAL_NORMALMAP_SCALE)\n    uv *= (MATERIAL_NORMALMAP_SCALE).xy;\n        #endif\n        \n    normal = SAMPLER_FNC(MATERIAL_NORMALMAP, uv).xyz;\n    normal = v_tangentToWorld * (normal * 2.0 - 1.0);\n\n    #elif defined(MODEL_VERTEX_TANGENT) && defined(MODEL_VERTEX_TEXCOORD) && defined(MATERIAL_BUMPMAP_NORMALMAP)\n    vec2 uv = v_texcoord.xy;\n        #if defined(MATERIAL_BUMPMAP_OFFSET)\n    uv += (MATERIAL_BUMPMAP_OFFSET).xy;\n        #endif\n        #if defined(MATERIAL_BUMPMAP_SCALE)\n    uv *= (MATERIAL_BUMPMAP_SCALE).xy;\n        #endif\n    normal = v_tangentToWorld * ( SAMPLER_FNC(MATERIAL_BUMPMAP_NORMALMAP, uv).xyz * 2.0 - 1.0) ;\n    #endif\n#endif\n\n    return normal;\n}\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Convert diffuse/specular/glossiness workflow to PBR metallic factor\nuse: <float> toMetallic(<vec3> diffuse, <vec3> specular, <float> maxSpecular)\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef TOMETALLIC_MIN_REFLECTANCE\n#define TOMETALLIC_MIN_REFLECTANCE 0.04\n#endif\n\n#ifndef FNC_TOMETALLIC\n#define FNC_TOMETALLIC\n\nfloat toMetallic(const in vec3 diffuse, const in vec3 specular, const in float maxSpecular) {\n    float perceivedDiffuse = sqrt(0.299 * diffuse.r * diffuse.r + 0.587 * diffuse.g * diffuse.g + 0.114 * diffuse.b * diffuse.b);\n    float perceivedSpecular = sqrt(0.299 * specular.r * specular.r + 0.587 * specular.g * specular.g + 0.114 * specular.b * specular.b);\n    if (perceivedSpecular < TOMETALLIC_MIN_REFLECTANCE) {\n        return 0.0;\n    }\n    float a = TOMETALLIC_MIN_REFLECTANCE;\n    float b = perceivedDiffuse * (1.0 - maxSpecular) / (1.0 - TOMETALLIC_MIN_REFLECTANCE) + perceivedSpecular - 2.0 * TOMETALLIC_MIN_REFLECTANCE;\n    float c = TOMETALLIC_MIN_REFLECTANCE - perceivedSpecular;\n    float D = max(b * b - 4.0 * a * c, 0.0);\n    return saturate((-b + sqrt(D)) / (2.0 * a));\n}\n\nfloat toMetallic(const in vec3 diffuse, const in vec3 specular) {\n    float maxSpecula = max(max(specular.r, specular.g), specular.b);\n    return toMetallic(diffuse, specular, maxSpecula);\n}\n\n#endif\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Get material metallic property from GlslViewer\'s defines https://github.com/patriciogonzalezvivo/glslViewer/wiki/GlslViewer-DEFINES#material-defines\nuse: vec4 materialMetallic()\noptions:\n    - SAMPLER_FNC(TEX, UV): optional depending the target version of GLSL (texture2D(...) or texture(...))\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_MATERIAL_METALLIC\n#define FNC_MATERIAL_METALLIC\n\n#ifdef MATERIAL_METALLICMAP\nuniform SAMPLER_TYPE MATERIAL_METALLICMAP;\n#endif\n\n#if defined(MATERIAL_ROUGHNESSMETALLICMAP) && !defined(MATERIAL_ROUGHNESSMETALLICMAP_UNIFORM)\n#define MATERIAL_ROUGHNESSMETALLICMAP_UNIFORM\nuniform SAMPLER_TYPE MATERIAL_ROUGHNESSMETALLICMAP;\n#endif\n\n#if defined(MATERIAL_OCCLUSIONROUGHNESSMETALLICMAP) && !defined(MATERIAL_OCCLUSIONROUGHNESSMETALLICMAP_UNIFORM)\n#define MATERIAL_OCCLUSIONROUGHNESSMETALLICMAP_UNIFORM\nuniform SAMPLER_TYPE MATERIAL_OCCLUSIONROUGHNESSMETALLICMAP;\n#endif\n    \nfloat materialMetallic() {\n    float metallic = 0.0;\n\n#if defined(MATERIAL_METALLICMAP) && defined(MODEL_VERTEX_TEXCOORD)\n    vec2 uv = v_texcoord.xy;\n    #if defined(MATERIAL_METALLICMAP_OFFSET)\n    uv += (MATERIAL_METALLICMAP_OFFSET).xy;\n    #endif\n    #if defined(MATERIAL_METALLICMAP_SCALE)\n    uv *= (MATERIAL_METALLICMAP_SCALE).xy;\n    #endif\n    metallic = SAMPLER_FNC(MATERIAL_METALLICMAP, uv).b;\n\n#elif defined(MATERIAL_ROUGHNESSMETALLICMAP) && defined(MODEL_VERTEX_TEXCOORD)\n    vec2 uv = v_texcoord.xy;\n    metallic = SAMPLER_FNC(MATERIAL_ROUGHNESSMETALLICMAP, uv).b;\n\n#elif defined(MATERIAL_OCCLUSIONROUGHNESSMETALLICMAP) && defined(MODEL_VERTEX_TEXCOORD)\n    vec2 uv = v_texcoord.xy;\n    metallic = SAMPLER_FNC(MATERIAL_OCCLUSIONROUGHNESSMETALLICMAP, uv).b;\n\n#elif defined(MATERIAL_METALLIC)\n    metallic = MATERIAL_METALLIC;\n\n#else\n    vec3 diffuse = materialAlbedo().rgb;\n    vec3 specular = materialSpecular();\n    metallic = toMetallic(diffuse, specular);\n#endif\n\n    return metallic;\n}\n\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Get material roughness property from GlslViewer\'s defines https://github.com/patriciogonzalezvivo/glslViewer/wiki/GlslViewer-DEFINES#material-defines\nuse: vec4 materialRoughness()\noptions:\n    - SAMPLER_FNC(TEX, UV): optional depending the target version of GLSL (texture2D(...) or texture(...))\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_MATERIAL_ROUGHNESS\n#define FNC_MATERIAL_ROUGHNESS\n\n#ifdef MATERIAL_ROUGHNESSMAP\nuniform SAMPLER_TYPE MATERIAL_ROUGHNESSMAP;\n#endif\n\n#if defined(MATERIAL_ROUGHNESSMETALLICMAP) && !defined(MATERIAL_ROUGHNESSMETALLICMAP_UNIFORM)\n#define MATERIAL_ROUGHNESSMETALLICMAP_UNIFORM\nuniform SAMPLER_TYPE MATERIAL_ROUGHNESSMETALLICMAP;\n#endif\n\n#if defined(MATERIAL_OCCLUSIONROUGHNESSMETALLICMAP) && !defined(MATERIAL_OCCLUSIONROUGHNESSMETALLICMAP_UNIFORM)\n#define MATERIAL_OCCLUSIONROUGHNESSMETALLICMAP_UNIFORM\nuniform SAMPLER_TYPE MATERIAL_OCCLUSIONROUGHNESSMETALLICMAP;\n#endif\n\nfloat materialRoughness() {\n    float roughness = 0.05;\n\n#if defined(MATERIAL_ROUGHNESSMAP) && defined(MODEL_VERTEX_TEXCOORD)\n    vec2 uv = v_texcoord.xy;\n    #if defined(MATERIAL_ROUGHNESSMAP_OFFSET)\n    uv += (MATERIAL_ROUGHNESSMAP_OFFSET).xy;\n    #endif\n    #if defined(MATERIAL_ROUGHNESSMAP_SCALE)\n    uv *= (MATERIAL_ROUGHNESSMAP_SCALE).xy;\n    #endif\n    roughness = max(roughness, SAMPLER_FNC(MATERIAL_ROUGHNESSMAP, uv).g);\n\n#elif defined(MATERIAL_ROUGHNESSMETALLICMAP) && defined(MODEL_VERTEX_TEXCOORD)\n    vec2 uv = v_texcoord.xy;\n    roughness = max(roughness, SAMPLER_FNC(MATERIAL_ROUGHNESSMETALLICMAP, uv).g);\n\n#elif defined(MATERIAL_OCCLUSIONROUGHNESSMETALLICMAP) && defined(MODEL_VERTEX_TEXCOORD)\n    vec2 uv = v_texcoord.xy;\n    roughness = max(roughness, SAMPLER_FNC(MATERIAL_OCCLUSIONROUGHNESSMETALLICMAP, uv).g);\n\n#elif defined(MATERIAL_ROUGHNESS)\n    roughness = MATERIAL_ROUGHNESS;\n\n#endif\n\n    return roughness;\n}\n\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Convertes from PBR roughness/metallic to a shininess factor (typaclly use on diffuse/specular/ambient workflow)\nuse: float toShininess(<float> roughness, <float> metallic)\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_TOSHININESS\n#define FNC_TOSHININESS\nfloat toShininess(const in float roughness, const in float metallic) {\n    float s = .95 - roughness * 0.5;\n    s *= s;\n    s *= s;\n    return s * (80.0 + 160.0 * (1.0-metallic));\n}\n#endif\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Get material shininess property from GlslViewer\'s defines https://github.com/patriciogonzalezvivo/glslViewer/wiki/GlslViewer-DEFINES#material-defines\nuse: vec4 materialShininess()\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_MATERIAL_SHININESS\n#define FNC_MATERIAL_SHININESS\n\nfloat materialShininess() {\n    float shininess = 15.0;\n\n#ifdef MATERIAL_SHININESS\n    shininess = MATERIAL_SHININESS;\n\n#elif defined(FNC_MATERIAL_METALLIC) && defined(MATERIAL_METALLIC) && defined(FNC_MATERIAL_ROUGHNESS) && defined(MATERIAL_ROUGHNESS)\n    float roughness = materialRoughness();\n    float metallic = materialMetallic();\n    shininess = toShininess(roughness, metallic);\n#endif\n\n    return shininess;\n}\n\n#endif\n\n\n\n\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Generic Material Structure\noptions:\n    - SCENE_BACK_SURFACE\n    - SHADING_MODEL_CLEAR_COAT\n    - MATERIAL_HAS_CLEAR_COAT_NORMAL\n    - SHADING_MODEL_IRIDESCENCE\n    - SHADING_MODEL_SUBSURFACE\n    - SHADING_MODEL_CLOTH\n    - SHADING_MODEL_SPECULAR_GLOSSINESS\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#if !defined(MATERIAL_OPT_IN)\n#define RENDER_RAYMARCHING\n#define SHADING_MODEL_CLEAR_COAT\n#endif\n\n#ifndef STR_MATERIAL\n#define STR_MATERIAL\nstruct Material {\n    vec4    albedo;\n    vec3    emissive;\n\n    vec3    position;       // world position of the surface\n    vec3    normal;         // world normal of the surface\n\n#if defined(RENDER_RAYMARCHING)\n    float   sdf;\n    bool    valid;\n#endif\n\n    #if defined(SCENE_BACK_SURFACE)\n    vec3    normal_back;    // world normal of the back surface of the model\n    #endif\n    \n    vec3    ior;            // Index of Refraction\n\n    float   roughness;\n    float   metallic;\n    float   reflectance;\n    float   ambientOcclusion;   // default 1.0\n\n#if defined(SHADING_MODEL_CLEAR_COAT)\n    float   clearCoat;\n    float   clearCoatRoughness;\n    #if defined(MATERIAL_HAS_CLEAR_COAT_NORMAL)\n    vec3    clearCoatNormal;    // default vec3(0.0, 0.0, 1.0);\n    #endif\n#endif\n\n#if defined(SHADING_MODEL_IRIDESCENCE)\n    float   thickness; // default to 300.0\n#endif\n\n#if defined(SHADING_MODEL_SUBSURFACE)\n    vec3    subsurfaceColor;    // default vec3(1.0)\n    float   subsurfacePower;    // default to 12.234\n    float   subsurfaceThickness;// default to 1.0\n#endif\n\n};\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Refractive index of different materials based on https://en.wikipedia.org/wiki/Refractive_index\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n#ifndef IOR_AIR\n#define IOR_AIR 1.000293\n#endif\n\n#ifndef IOR_ICE\n#define IOR_ICE 1.31\n#endif\n\n#ifndef IOR_WATER\n#define IOR_WATER 1.333\n#endif\n\n#ifndef IOR_WATER_RGB\n#define IOR_WATER_RGB vec3(1.337, 1.333, 1.331)\n#endif\n\n#ifndef IOR_GLYCERING\n#define IOR_GLYCERING 1.473\n#endif\n\n#ifndef IOR_OIL\n#define IOR_OIL 1.515\n#endif\n\n#ifndef IOR_OIL_RGB\n#define IOR_OIL_RGB vec3(1.530, 1.520, 1.516)\n#endif\n\n#ifndef IOR_GLASS\n#define IOR_GLASS 1.5168\n#endif\n\n#ifndef IOR_GLASS_RGB\n#define IOR_GLASS_RGB vec3(1.524, 1.517, 1.515)\n#endif\n\n#ifndef IOR_GLASS_FLINT \n#define IOR_GLASS_FLINT 1.69\n#endif\n\n#ifndef IOR_GLASS_FLINT_RGB \n#define IOR_GLASS_FLINT_RGB vec3(1.639, 1.627, 1.622)\n#endif\n\n#ifndef IOR_SAPPHIRE\n#define IOR_SAPPHIRE 1.77\n#endif\n\n#ifndef IOR_DIAMONG\n#define IOR_DIAMONG 2.42\n#endif\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: |\n    Material Constructor. Designed to integrate with GlslViewer\'s defines https://github.com/patriciogonzalezvivo/glslViewer/wiki/GlslViewer-DEFINES#material-defines\nuse:\n    - void materialNew(out <material> _mat)\n    - <material> materialNew()\noptions:\n    - SURFACE_POSITION\n    - SCENE_BACK_SURFACE\n    - SHADING_MODEL_CLEAR_COAT\n    - MATERIAL_HAS_CLEAR_COAT_NORMAL\n    - SHADING_MODEL_IRIDESCENCE\n    - SHADING_MODEL_SUBSURFACE\n    - SHADING_MODEL_CLOTH\n    - SHADING_MODEL_SPECULAR_GLOSSINESS\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef SURFACE_POSITION\n#define SURFACE_POSITION vec3(0.0, 0.0, 0.0)\n#endif\n\n#ifndef RAYMARCH_MAX_DIST\n#define RAYMARCH_MAX_DIST 20.0\n#endif\n\n#ifndef FNC_MATERIAL_NEW\n#define FNC_MATERIAL_NEW\n\nvoid materialNew(out Material _mat) {\n    // Surface data\n    _mat.position           = (SURFACE_POSITION).xyz;\n    _mat.normal             = materialNormal();\n\n#if defined(RENDER_RAYMARCHING)\n    _mat.sdf                = RAYMARCH_MAX_DIST;\n    _mat.valid              = true;\n#endif\n\n    #if defined(SCENE_BACK_SURFACE) && defined(RESOLUTION)\n        vec4 back_surface       = SAMPLER_FNC(SCENE_BACK_SURFACE, gl_FragCoord.xy / RESOLUTION);\n        _mat.normal_back        = back_surface.xyz;\n    #else\n        #if defined(SCENE_BACK_SURFACE)\n        // Naive assumption of the back surface\n        _mat.normal_back        = -_mat.normal;\n        #endif\n    #endif\n\n    // PBR Properties\n    _mat.albedo             = materialAlbedo();\n    _mat.emissive           = materialEmissive();\n    _mat.roughness          = materialRoughness();\n    _mat.metallic           = materialMetallic();\n    _mat.reflectance        = 0.5;\n\n    _mat.ior                = vec3(IOR_GLASS_RGB);      // Index of Refraction\n\n    _mat.ambientOcclusion   = materialOcclusion();\n\n#if defined (SHADING_MODEL_CLEAR_COAT)\n    _mat.clearCoat          = 0.0;\n    _mat.clearCoatRoughness = 0.01;\n    #if defined(MATERIAL_HAS_CLEAR_COAT_NORMAL)\n    _mat.clearCoatNormal    = vec3(0.0, 0.0, 1.0);\n    #endif\n#endif\n\n#if defined(SHADING_MODEL_IRIDESCENCE)\n    _mat.thickness          = 300.0;\n#endif\n\n#if defined(SHADING_MODEL_SUBSURFACE)\n    _mat.subsurfaceColor    = _mat.albedo.rgb;\n    _mat.subsurfacePower    = 12.234;\n    _mat.subsurfaceThickness = 20.0;\n\n    // Simulate Absorption Using Depth Map (shadowmap)\n    // https://developer.nvidia.com/gpugems/gpugems/part-iii-materials/chapter-16-real-time-approximations-subsurface-scattering\n    #if defined(LIGHT_SHADOWMAP) && defined(LIGHT_COORD)\n    {\n        vec3 shadowCoord = LIGHT_COORD.xyz / LIGHT_COORD.w;\n        float Di = SAMPLER_FNC(LIGHT_SHADOWMAP, LIGHT_COORD.xy).r;\n        float Do = LIGHT_COORD.z;\n        float delta = Do - Di;\n\n        #if defined(LIGHT_SHADOWMAP_SIZE) && !defined(PLATFORM_RPI)\n        vec2 shadowmap_pixel = 1.0/vec2(LIGHT_SHADOWMAP_SIZE);\n        shadowmap_pixel *= pow(delta, 0.6) * 20.0;\n\n        Di = 0.0;\n        for (float x= -2.0; x <= 2.0; x++)\n            for (float y= -2.0; y <= 2.0; y++) \n                Di += SAMPLER_FNC(LIGHT_SHADOWMAP, LIGHT_COORD.xy + vec2(x,y) * shadowmap_pixel).r;\n        Di *= 0.04; // 1.0/25.0\n        delta = Do - Di;\n        #endif\n\n        // This is pretty much of a hack by overwriting the absorption to the thinkness\n        _mat.subsurfaceThickness = max(Do - Di, 0.005) * 30.0;\n    }\n    #endif\n\n#endif\n}\n\nMaterial materialNew() {\n    Material mat;\n    materialNew(mat);\n    return mat;\n}\n\nMaterial materialNew(vec3 albedo, float sdf) {\n    Material mat = materialNew();\n    mat.albedo.rgb = albedo;\n    mat.sdf = sdf;\n    return mat;\n}\n\nMaterial materialNew(vec3 albedo, float roughness, float metallic, float sdf) {\n    Material mat = materialNew();\n    mat.albedo.rgb = albedo;\n    mat.metallic = metallic;\n    mat.roughness = roughness;\n    mat.sdf = sdf;\n    return mat;\n}\n\n#endif\n\n\n\n\n/*\ncontributors:  Shadi El Hajj\ndescription: Structure to hold shading variables\nlicense: MIT License (MIT) Copyright (c) 2024 Shadi EL Hajj\n*/\n\n#ifndef STR_SHADING_DATA\n#define STR_SHADING_DATA\n\nstruct ShadingData {\n   vec3 V;\n   vec3 N;\n   vec3 H;\n   vec3 L;\n   vec3 R;\n\n   float NoV;\n   float NoL;\n   float NoH;\n\n   float roughness;\n   float linearRoughness;\n   vec3 diffuseColor;\n   vec3 specularColor;\n\n   vec3 energyCompensation;\n\n   vec3 directDiffuse;\n   vec3 directSpecular;\n   vec3 indirectDiffuse;\n   vec3 indirectSpecular;\n};\n\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: |\n    This function calculates the reflection vector of a given vector and normal.\n    It also takes into account the roughness of the material.\n    If MATERIAL_ANISOTROPY is defined, it will also take into account the anisotropy direction.\n    If MODEL_VERTEX_TANGENT is defined, it will use the tangentToWorld matrix to calculate the anisotropy direction.\nuse: <vec3> reflection(<vec3> vector, <vec3> normal, <float> roughness);\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_REFLECTION\n#define FNC_REFLECTION\n\nvec3 reflection(const in vec3 _V, const in vec3 _N, const in float _roughness) {\n        // Reflect\n#ifdef MATERIAL_ANISOTROPY\n    vec3  anisotropicT = MATERIAL_ANISOTROPY_DIRECTION;\n    vec3  anisotropicB = MATERIAL_ANISOTROPY_DIRECTION;\n\n    #ifdef MODEL_VERTEX_TANGENT\n    anisotropicT = normalize(v_tangentToWorld * MATERIAL_ANISOTROPY_DIRECTION);\n    anisotropicB = normalize(cross(v_tangentToWorld[2], anisotropicT));\n    #endif\n\n    vec3  anisotropyDirection = MATERIAL_ANISOTROPY >= 0.0 ? anisotropicB : anisotropicT;\n    vec3  anisotropicTangent  = cross(anisotropyDirection, _V);\n    vec3  anisotropicNormal   = cross(anisotropicTangent, anisotropyDirection);\n    float bendFactor          = abs(MATERIAL_ANISOTROPY) * saturate(5.0 * _roughness);\n    vec3  bentNormal          = normalize(mix(_N, anisotropicNormal, bendFactor));\n    return reflect(-_V, bentNormal);\n#else\n\n    return reflect(-_V, _N);\n#endif\n\n}\n\n#endif\n\n\n/*\ncontributors: Shadi El Hajj\ndescription: Compute F0 for perceptual reflectance parameter. From Sbastien Lagarde\'s paper "Moving Frostbite to PBR".\nuse: <float> reflectance2f0(<float> reflectance)\nlicense: MIT License (MIT) Copyright (c) 2024 Shadi EL Hajj\n*/\n\n#ifndef FNC_REFLECTANCE2F0\n#define FNC_REFLECTANCE2F0\nfloat reflectance2f0(const float reflectance) { return 0.16 * reflectance * reflectance; }\n#endif\n\n\n/*\ncontributors: Shadi El Hajj\ndescription: Classic Disney reparametrisation of roughness from Burley\'s paper "Physically Based Shading At Disney". Sbastien Lagarde\'s recommends clamping perceptual roughness to 0.045 in his paper "Moving Frostbite to PBR".\nuse: <float> perceptual2linearRoughness(<float> perceptualRoughness)\nlicense: MIT License (MIT) Copyright (c) 2024 Shadi EL Hajj\n*/\n\n#ifndef MIN_PERCEPTUAL_ROUGHNESS\n#define MIN_PERCEPTUAL_ROUGHNESS 0.045\n#endif\n\n#ifndef FNC_PERCEPTUAL_LINEAR_ROUGHNESS\n#define FNC_PERCEPTUAL_LINEAR_ROUGHNESS\n\nfloat perceptual2linearRoughness(float perceptualRoughness) {\n    perceptualRoughness = clamp(perceptualRoughness, MIN_PERCEPTUAL_ROUGHNESS, 1.0);\n    return perceptualRoughness * perceptualRoughness;\n}\n\n#endif\n\n\n/*\ncontributors:  Shadi El Hajj\ndescription: ShadingData constructor\nlicense: MIT License (MIT) Copyright (c) 2024 Shadi EL Hajj\n*/\n\n#ifndef FNC_SHADING_DATA_NEW\n#define FNC_SHADING_DATA_NEW \n\nShadingData shadingDataNew() {\n   ShadingData shadingData;\n\n   shadingData.V = vec3(0.0, 0.0, 0.0);\n   shadingData.N = vec3(0.0, 0.0, 0.0);\n   shadingData.H = vec3(0.0, 0.0, 0.0);\n   shadingData.L = vec3(0.0, 0.0, 0.0);\n   shadingData.R = vec3(0.0, 0.0, 0.0);\n\n   shadingData.NoV = 0.0;\n   shadingData.NoL = 0.0;\n   shadingData.NoH = 0.0;\n\n   shadingData.roughness = 0.0;\n   shadingData.linearRoughness = 0.0;\n   shadingData.diffuseColor = vec3(0.0, 0.0, 0.0);\n   shadingData.specularColor = vec3(0.0, 0.0, 0.0);\n\n   shadingData.energyCompensation = vec3(1.0, 1.0, 1.0);\n\n   shadingData.directDiffuse = vec3(0.0, 0.0, 0.0);\n   shadingData.directSpecular = vec3(0.0, 0.0, 0.0);\n   shadingData.indirectDiffuse = vec3(0.0, 0.0, 0.0);\n   shadingData.indirectSpecular = vec3(0.0, 0.0, 0.0);\n\n   return shadingData;\n}\n\nvoid shadingDataNew(Material mat, inout ShadingData shadingData) {\n   float dielectricF0 = reflectance2f0(mat.reflectance);\n   shadingData.N = mat.normal;\n   shadingData.R = reflection(shadingData.V, shadingData.N, mat.roughness);\n   shadingData.NoV = dot(shadingData.N, shadingData.V);\n   shadingData.roughness = max(mat.roughness, MIN_PERCEPTUAL_ROUGHNESS);\n   shadingData.linearRoughness = perceptual2linearRoughness(shadingData.roughness);\n   shadingData.diffuseColor = mat.albedo.rgb * (1.0 - mat.metallic);\n   shadingData.specularColor = mix(vec3(dielectricF0, dielectricF0, dielectricF0), mat.albedo.rgb, mat.metallic);\n}\n\n#endif\n\n\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: fast approximation to pow()\nuse: <float> powFast(<float> x, <float> exp)\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_POWFAST\n#define FNC_POWFAST\n\nfloat powFast(const in float a, const in float b) { return a / ((1. - b) * a + b); }\n\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: triplanar mapping\nuse: <vec4> sample2DCube(in <SAMPLER_TYPE> lut, in <vec3> xyz)\noptions:\n    - SAMPLER_FNC(TEX, UV): optional depending the target version of GLSL (texture2D(...) or texture(...))\n    - SAMPLETRIPLANAR_TYPE: optional depending the target version of GLSL (vec4 or vec3)\n    - SAMPLETRIPLANAR_FNC(TEX, UV): optional depending the target version of GLSL (texture2D(...) or texture(...))\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef SAMPLETRIPLANAR_TYPE\n#define SAMPLETRIPLANAR_TYPE vec4\n#endif\n\n#ifndef SAMPLETRIPLANAR_FNC\n#define SAMPLETRIPLANAR_FNC(TEX, UV) SAMPLER_FNC(TEX, UV)\n#endif\n\n#ifndef FNC_SAMPLETRIPLANAR\n#define FNC_SAMPLETRIPLANAR\nSAMPLETRIPLANAR_TYPE sampleTriplanar(SAMPLER_TYPE tex, in vec3 d) {\n    SAMPLETRIPLANAR_TYPE colx = SAMPLETRIPLANAR_FNC(tex, d.yz);\n    SAMPLETRIPLANAR_TYPE coly = SAMPLETRIPLANAR_FNC(tex, d.zx);\n    SAMPLETRIPLANAR_TYPE colz = SAMPLETRIPLANAR_FNC(tex, d.xy);\n    \n    vec3 n = d*d;\n    return (colx*n.x + coly*n.y + colz*n.z)/(n.x+n.y+n.z);\n}\n\n// iq\'s cubemap function\nSAMPLETRIPLANAR_TYPE sampleTriplanar(SAMPLER_TYPE tex, in vec3 d, in float s) {\n    SAMPLETRIPLANAR_TYPE colx = SAMPLETRIPLANAR_FNC(tex, 0.5 + s*d.yz/d.x);\n    SAMPLETRIPLANAR_TYPE coly = SAMPLETRIPLANAR_FNC(tex, 0.5 + s*d.zx/d.y);\n    SAMPLETRIPLANAR_TYPE colz = SAMPLETRIPLANAR_FNC(tex, 0.5 + s*d.xy/d.z);\n    \n    vec3 n = d*d;\n    return (colx*n.x + coly*n.y + colz*n.z)/(n.x+n.y+n.z);\n}\n#endif\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Creates a fake cube and returns the value giving a normal direction\nuse: <vec3> fakeCube(<vec3> _normal [, <float> _shininnes])\noptions:\n    - FAKECUBE_LIGHT_AMOUNT: amount of light to fake\n    - FAKECUBE_ONLYXWALL: only the x wall is lit\n    - FAKECUBE_ONLYYWALL: only the y wall is lit\n    - FAKECUBE_ONLYZWALL: only the z wall is lit\n    - FAKECUBE_NOFLOOR: removes the floor from the fake cube\n    - FAKECUBE_NOROOF: removes the floor from the fake cube\n    - FAKECUBE_NOXWALL: removes the x wall from the fake cube\n    - FAKECUBE_NONXWALL: removes the -x wall from the fake cube\n    - FAKECUBE_NOZWALL: removes the z wall from the fake cube\n    - FAKECUBE_NOMZWALL: removes the -z wall from the fake cube\n    - FAKECUBE_TEXTURE2D: function to sample the fake cube\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FAKECUBE_LIGHT_AMOUNT\n#define FAKECUBE_LIGHT_AMOUNT 0.005\n#endif\n\n#ifndef FNC_FAKECUBE\n#define FNC_FAKECUBE\n\nvec3 fakeCube(const in vec3 _normal, const in float _shininnes) {\n\n    #if defined(FAKECUBE_TEXTURE2D)\n    return sampleTriplanar(FAKECUBE_TEXTURE2D, _normal);\n\n    #elif defined(FAKECUBE_ONLYXWALL)\n    return vec3( powFast(saturate(_normal.x) + FAKECUBE_LIGHT_AMOUNT, _shininnes) );\n\n    #elif defined(FAKECUBE_ONLYYWALL)\n    return vec3( powFast(saturate(_normal.y) + FAKECUBE_LIGHT_AMOUNT, _shininnes) );\n\n    #elif defined(FAKECUBE_ONLYZWALL)\n    return vec3( powFast(saturate(_normal.z) + FAKECUBE_LIGHT_AMOUNT, _shininnes) );\n\n    #else\n    vec3 rAbs = abs(_normal);\n    return vec3( powFast(max(max(rAbs.x, rAbs.y), rAbs.z) + FAKECUBE_LIGHT_AMOUNT, _shininnes)\n        #ifdef FAKECUBE_NOFLOOR\n        * smoothstep(-1.0, 0., _normal.y) \n        #endif\n\n        #ifdef FAKECUBE_NOROOF\n        * smoothstep(1.0, 0., _normal.y) \n        #endif\n\n        #ifdef FAKECUBE_NOXWALL\n        * smoothstep(1.0, 0.0, _normal.x) \n        #endif\n\n        #ifdef FAKECUBE_NONXWALL\n        * smoothstep(-1.0, 0., _normal.x) \n        #endif\n\n        #ifdef FAKECUBE_NOZWALL\n        * smoothstep(-1.0, 0., _normal.z) \n        #endif\n\n        #ifdef FAKECUBE_NONZWALL\n        * smoothstep(1.0, 0., _normal.z) \n        #endif\n    );\n\n    #endif\n}\n\nvec3 fakeCube(const in vec3 _normal) {\n    return fakeCube(_normal, materialShininess() );\n}\n\n#endif\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: |\n    Get environment map light coming from a normal direction and according\n    to some roughness/metallic value. If there is no SCENE_CUBEMAP texture it creates\n    a fake cube\nuse: <vec3> envMap(<vec3> _normal, <float> _roughness [, <float> _metallic])\noptions:\n    - SCENE_CUBEMAP: pointing to the cubemap texture\n    - ENVMAP_MAX_MIP_LEVEL\n    - ENVMAP_LOD_OFFSET\n    - ENVMAP_FNC(NORMAL, ROUGHNESS, METALLIC)\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef SAMPLE_CUBE_FNC\n#if __VERSION__ >= 300\n#define SAMPLE_CUBE_FNC(CUBEMAP, NORM, LOD) textureLod(CUBEMAP, NORM, LOD)\n#else\n#define SAMPLE_CUBE_FNC(CUBEMAP, NORM, LOD) textureCube(CUBEMAP, NORM, LOD)\n#endif\n#endif\n\n#if !defined(ENVMAP_MAX_MIP_LEVEL) && __VERSION__ < 430\n#define ENVMAP_MAX_MIP_LEVEL 3.0\n#endif\n\n#ifndef ENVMAP_LOD_OFFSET\n#define ENVMAP_LOD_OFFSET 0\n#endif\n\n#ifndef FNC_ENVMAP\n#define FNC_ENVMAP\n\nfloat envMapRoughnessToLod(float roughness, float roughnessOneLevel) {\n    // quadratic fit for log2(roughness)+roughnessOneLevel\n    return roughnessOneLevel * roughness * (2.0 - roughness);\n}\n\nvec3 envMap(const in vec3 _normal, const in float _roughness, const in float _metallic) {\n\n// ENVMAP overwrites cube sampling  \n#if defined(ENVMAP_FNC) \n    return ENVMAP_FNC(_normal, _roughness, _metallic);\n\n#elif defined(SCENE_EQUIRECT)\n    return sampleEquirect(SCENE_EQUIRECT, _normal, 1.0 + 26.0 * _roughness).rgb;\n\n// Cubemap sampling\n#elif defined(SCENE_CUBEMAP) && !defined(ENVMAP_MAX_MIP_LEVEL)\n    int roughnessOneLevel = textureQueryLevels(SCENE_CUBEMAP) - ENVMAP_LOD_OFFSET - 1;\n    return SAMPLE_CUBE_FNC( SCENE_CUBEMAP, _normal, envMapRoughnessToLod(_roughness, float(roughnessOneLevel)) ).rgb;\n\n#elif defined(SCENE_CUBEMAP)\n    return SAMPLE_CUBE_FNC( SCENE_CUBEMAP, _normal, envMapRoughnessToLod(_roughness, ENVMAP_MAX_MIP_LEVEL) ).rgb;\n\n// Default\n#else\n    return fakeCube(_normal, toShininess(_roughness, _metallic));\n\n#endif\n}\n\nvec3 envMap(const in vec3 _normal, const in float _roughness) {\n    return envMap(_normal, _roughness, 1.0);\n}\n\nvec3 envMap(const in Material _M, ShadingData shadingData) {\n    return envMap(shadingData.R, _M.roughness, _M.metallic);\n}\n\n#endif\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: "Resolve fresnel coefficient and apply it to a reflection. It can apply     iridescence to \nusing a formula based on https://www.alanzucconi.com/2017/07/25/the-mathematics-of-thin-film-interference/\n"\nuse:\n    - <vec3> fresnelReflection(<vec3> R, <vec3> f0, <float> NoV)\n    - <vec3> fresnelIridescentReflection(<vec3> normal, <vec3> view, <vec3> f0, <vec3> ior1, <vec3> ior2, <float> thickness, <float> roughness)\n    - <vec3> fresnelReflection(<Material> _M)\noptions:\n    - FRESNEL_REFLECTION_RGB: <vec3> RGB values of the reflection\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FRESNEL_REFLECTION_RGB\n#define FRESNEL_REFLECTION_RGB vec3(612.0, 549.0, 464.0)\n#endif\n\n#ifndef FNC_FRESNEL_REFLECTION\n#define FNC_FRESNEL_REFLECTION\n\nvec3 fresnelReflection(const in vec3 R, const in vec3 f0, const in float NoV) {\n    vec3 frsnl = fresnel(f0, NoV);\n\n    vec3 reflectColor = vec3(0.0);\n    #if defined(FRESNEL_REFLECTION_FNC)\n    reflectColor = FRESNEL_REFLECTION_FNC(R);\n    #else\n    reflectColor = envMap(R, 1.0, 0.001);\n    #endif\n\n    return reflectColor * frsnl;\n}\n\nvec3 fresnelReflection(const in vec3 R, const in vec3 Fr) {\n    vec3 reflectColor = vec3(0.0);\n    #if defined(FRESNEL_REFLECTION_FNC)\n    reflectColor = FRESNEL_REFLECTION_FNC(R);\n    #else\n    reflectColor = envMap(R, 1.0, 0.001);\n    #endif\n    return reflectColor * Fr;\n}\n\nvec3 fresnelIridescentReflection(vec3 normal, vec3 view, float f0, float ior1, float ior2, float thickness, float roughness, \n                                 inout float Fr) {\n    float cos0 = -dot(view, normal);\n    Fr = fresnel(f0, cos0);\n    float T = 1.0 - Fr;\n    float a = ior1/ior2;\n    float cosi2 = sqrt(1.0 - a * a * (1.0 - cos0*cos0));\n    vec3 shift = 4.0 * PI * (thickness/FRESNEL_REFLECTION_RGB) * ior2 * cosi2 + HALF_PI;\n    vec3 irid = Fr * ( 1.0 + T * ( T + 2.0 * cos(shift) ) );\n    vec3 ref = envMap(reflect(view, normal), roughness, 0.0);\n    return (ref + pow5(ref)) * irid;\n}\n\nvec3 fresnelIridescentReflection(vec3 normal, vec3 view, float f0, float ior1, float ior2, float thickness, float roughness) {\n    float Fr = 0.0;\n    return fresnelIridescentReflection(normal, view, f0, ior1, ior2, thickness, roughness, Fr);\n}\n\nvec3 fresnelIridescentReflection(vec3 normal, vec3 view, vec3 f0, vec3 ior1, vec3 ior2, float thickness, float roughness,\n                                 inout vec3 Fr) {\n    float cos0 = -dot(view, normal);\n    Fr = fresnel(f0, cos0);\n    vec3 T = 1.0 - Fr;\n    vec3 a = ior1/ior2;\n    vec3 cosi2 = sqrt(1.0 - a * a * (1.0 - cos0*cos0));\n    vec3 shift = 4.0 * PI * (thickness/FRESNEL_REFLECTION_RGB) * ior2 * cosi2 + HALF_PI;\n    vec3 irid = Fr * ( 1.0 + T * ( T + 2.0 * cos(shift) ) );\n    vec3 ref = envMap(reflect(view, normal), roughness, 0.0);\n    return (ref + pow5(ref)) * irid;\n}\n\nvec3 fresnelIridescentReflection(vec3 normal, vec3 view, vec3 f0, vec3 ior1, vec3 ior2, float thickness, float roughness) {\n    vec3 Fr = vec3(0.0);\n    return fresnelIridescentReflection(normal, view, f0, ior1, ior2, thickness, roughness, Fr);\n}\n\nvec3 fresnelIridescentReflection(vec3 normal, vec3 view, float ior1, float ior2, float thickness, float roughness) {\n    float F0 = (ior2-1.)/(ior2+1.);\n    return fresnelIridescentReflection(normal, view, F0 * F0, ior1, ior2, thickness, roughness);\n}\n\nvec3 fresnelIridescentReflection(vec3 normal, vec3 view, vec3 ior1, vec3 ior2, float thickness, float roughness) {\n    vec3 F0 = (ior2-1.)/(ior2+1.);\n    return fresnelIridescentReflection(normal, view, F0 * F0, ior1, ior2, thickness, roughness);\n}\n\nvec3 fresnelReflection(Material _M, ShadingData shadingData) {\n    vec3 f0 = vec3(0.04, 0.04, 0.04);\n    #if defined(SHADING_MODEL_IRIDESCENCE)\n    return fresnelIridescentReflection(_M.normal, -shadingData.V, f0, vec3(IOR_AIR, IOR_AIR, IOR_AIR), _M.ior, _M.thickness, _M.roughness);\n    #else\n    return fresnelReflection(shadingData.R, f0, shadingData.NoV) * (1.0-_M.roughness);\n    #endif\n}\n\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Index of refraction to ratio of index of refraction\nuse: <float|vec3|vec4> ior2eta(<float|vec3|vec4> ior)\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_IOR2ETA\n#define FNC_IOR2ETA\nfloat ior2eta( const in float ior ) { return 1.0/ior; }\nvec3 ior2eta( const in vec3 ior ) { return 1.0/ior; }\nvec4 ior2eta( const in vec4 ior ) { return vec4(1.0/ior.rgb, ior.a); }\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: power of 2\nuse: <float|vec2|vec3|vec4> pow2(<float|vec2|vec3|vec4> v)\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_POW2\n#define FNC_POW2\n\nfloat pow2(const in float v) { return v * v; }\nvec2 pow2(const in vec2 v) { return v * v; }\nvec3 pow2(const in vec3 v) { return v * v; }\nvec4 pow2(const in vec4 v) { return v * v; }\n\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: Index of refraction to reflectance at 0 degree https://handlespixels.wordpress.com/tag/f0-reflectance/\nuse: <float|vec3|vec4> ior2f0(<float|vec3|vec4> ior)\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_IOR2F0\n#define FNC_IOR2F0\nfloat ior2f0(const in float ior) { return pow2(ior - 1.0) / pow2(ior + 1.0); }\nvec3 ior2f0(const in vec3 ior) { return pow2(ior - 1.0) / pow2(ior + 1.0); }\nvec4 ior2f0(const in vec4 ior) { return vec4(pow2(ior.rgb - 1.0) / pow2(ior.rgb + 1.0), ior.a); }\n#endif\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: This function simulates the refraction of light through a transparent material. It uses the Schlick\'s approximation to calculate the Fresnel reflection and the Snell\'s law to calculate the refraction. It also uses the envMap function to simulate the dispersion of light through the material.\nuse:\n    - <vec3> transparent(<vec3> normal, <vec3> view, <vec3> ior, <float> roughness)\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#if !defined(TRANSPARENT_DISPERSION) && defined(TRANSPARENT_DISPERSION_PASSES)\n#define TRANSPARENT_DISPERSION 0.05\n#elif defined(TRANSPARENT_DISPERSION) && !defined(TRANSPARENT_DISPERSION_PASSES)\n#define TRANSPARENT_DISPERSION_PASSES 6\n#endif\n\n#ifndef FNC_TRANSPARENT\n#define FNC_TRANSPARENT\n\nvec3 transparent(vec3 normal, vec3 view, vec3 Fr, vec3 eta, float roughness) {\n    vec3 color  = vec3(0.0);\n    vec3 T      = max(vec3(0.0), 1.0-Fr);\n\n    #if defined(TRANSPARENT_DISPERSION) && defined(TRANSPARENT_DISPERSION_PASSES)\n        float pass_step = 1.0/float(TRANSPARENT_DISPERSION_PASSES);\n        vec3 bck = vec3(0.0);\n        for ( int i = 0; i < TRANSPARENT_DISPERSION_PASSES; i++ ) {\n            float slide = float(i) * pass_step * TRANSPARENT_DISPERSION;\n            vec3 R      = refract(view, normal, eta.g );\n            vec3 ref    = envMap(R, roughness, 0.0);\n\n            #if !defined(TRANSPARENT_DISPERSION_FAST) && !defined(TARGET_MOBILE) && !defined(PLATFORM_RPI)\n            ref.r       = envMap(refract(view, normal, eta.r - slide), roughness, 0.0).r;\n            ref.b       = envMap(refract(view, normal, eta.b + slide), roughness, 0.0).b;\n            #endif\n\n            bck += ref;\n        }\n        color.rgb   = bck * pass_step;\n    #else \n\n        vec3 R      = refract(view, normal, eta.g);\n        color       = envMap(R, roughness);\n\n        #if !defined(TRANSPARENT_DISPERSION_FAST) && !defined(TARGET_MOBILE) && !defined(PLATFORM_RPI)\n        vec3 RaR    = refract(view, normal, eta.r);\n        vec3 RaB    = refract(view, normal, eta.b);\n        color.r     = envMap(RaR, roughness).r;\n        color.b     = envMap(RaB, roughness).b;\n        #endif\n\n    #endif\n\n    return color*T*T*T*T;\n}\n\nvec3 transparent(vec3 normal, vec3 view, float Fr, vec3 eta, float roughness) {\n    vec3 color  = vec3(0.0);\n    float T     = max(0.0, 1.0-Fr);\n\n    #if defined(TRANSPARENT_DISPERSION) && defined(TRANSPARENT_DISPERSION_PASSES)\n        float pass_step = 1.0/float(TRANSPARENT_DISPERSION_PASSES);\n        vec3 bck = vec3(0.0);\n        for ( int i = 0; i < TRANSPARENT_DISPERSION_PASSES; i++ ) {\n            float slide = float(i) * pass_step * TRANSPARENT_DISPERSION;\n            vec3 R      = refract(view, normal, eta.g );\n            vec3 ref    = envMap(R, roughness, 0.0);\n\n            #if !defined(TRANSPARENT_DISPERSION_FAST) && !defined(TARGET_MOBILE) && !defined(PLATFORM_RPI)\n            ref.r       = envMap(refract(view, normal, eta.r - slide), roughness, 0.0).r;\n            ref.b       = envMap(refract(view, normal, eta.b + slide), roughness, 0.0).b;\n            #endif\n\n            bck += ref;\n        }\n        color.rgb   = bck * pass_step;\n    #else \n\n        vec3 R      = refract(view, normal, eta.g);\n        color       = envMap(R, roughness);\n\n        #if !defined(TRANSPARENT_DISPERSION_FAST) && !defined(TARGET_MOBILE) && !defined(PLATFORM_RPI)\n        vec3 RaR    = refract(view, normal, eta.r);\n        vec3 RaB    = refract(view, normal, eta.b);\n        color.r     = envMap(RaR, roughness).r;\n        color.b     = envMap(RaB, roughness).b;\n        #endif\n\n    #endif\n\n    return color*T*T*T*T;\n}\n\n#endif\n\n\n\n\n/*\ncontributors: Johan Ismael\ndescription: Sharpening convolutional operation\nuse: sharpen(<SAMPLER_TYPE> texture, <vec2> st, <vec2> pixel)\noptions:\n    - SAMPLER_FNC(TEX, UV): optional depending the target version of GLSL (texture2D(...) or texture(...))\n    - SHARPENFAST_KERNELSIZE: Defaults 2\n    - SHARPENFAST_TYPE: defaults to vec3\n    - SHARPENFAST_SAMPLER_FNC(TEX, UV): defaults to texture2D(tex, TEX, UV).rgb\n*/\n\n#ifndef SHARPENFAST_KERNELSIZE\n#ifdef SHARPEN_KERNELSIZE\n#define SHARPENFAST_KERNELSIZE SHARPEN_KERNELSIZE\n#else\n#define SHARPENFAST_KERNELSIZE 2\n#endif\n#endif\n\n#ifndef SHARPENFAST_TYPE\n#ifdef SHARPEN_TYPE\n#define SHARPENFAST_TYPE SHARPEN_TYPE\n#else\n#define SHARPENFAST_TYPE vec3\n#endif\n#endif\n\n#ifndef SHARPENFAST_SAMPLER_FNC\n#ifdef SHARPEN_SAMPLER_FNC\n#define SHARPENFAST_SAMPLER_FNC(TEX, UV) SHARPEN_SAMPLER_FNC(TEX, UV)\n#else\n#define SHARPENFAST_SAMPLER_FNC(TEX, UV) SAMPLER_FNC(TEX, UV).rgb\n#endif\n#endif\n\n#ifndef FNC_SHARPENFAST\n#define FNC_SHARPENFAST\nSHARPENFAST_TYPE sharpenFast(in SAMPLER_TYPE tex, in vec2 coords, in vec2 pixel, float strength) {\n    SHARPENFAST_TYPE sum = SHARPENFAST_TYPE(0.);\n    for (int i = 0; i < SHARPENFAST_KERNELSIZE; i++) {\n        float f_size = float(i) + 1.;\n        f_size *= strength;\n        sum += -1. * SHARPENFAST_SAMPLER_FNC(tex, coords + vec2( -1., 0.) * pixel * f_size);\n        sum += -1. * SHARPENFAST_SAMPLER_FNC(tex, coords + vec2( 0., -1.) * pixel * f_size);\n        sum +=  5. * SHARPENFAST_SAMPLER_FNC(tex, coords + vec2( 0., 0.) * pixel * f_size);\n        sum += -1. * SHARPENFAST_SAMPLER_FNC(tex, coords + vec2( 0., 1.) * pixel * f_size);\n        sum += -1. * SHARPENFAST_SAMPLER_FNC(tex, coords + vec2( 1., 0.) * pixel * f_size);\n    }\n    return sum / float(SHARPENFAST_KERNELSIZE);\n}\n\nSHARPENFAST_TYPE sharpenFast(in SAMPLER_TYPE tex, in vec2 coords, in vec2 pixel) {\n    SHARPENFAST_TYPE sum = SHARPENFAST_TYPE(0.);\n    for (int i = 0; i < SHARPENFAST_KERNELSIZE; i++) {\n        float f_size = float(i) + 1.;\n        sum += -1. * SHARPENFAST_SAMPLER_FNC(tex, coords + vec2( -1., 0.) * pixel * f_size);\n        sum += -1. * SHARPENFAST_SAMPLER_FNC(tex, coords + vec2( 0., -1.) * pixel * f_size);\n        sum +=  5. * SHARPENFAST_SAMPLER_FNC(tex, coords + vec2( 0., 0.) * pixel * f_size);\n        sum += -1. * SHARPENFAST_SAMPLER_FNC(tex, coords + vec2( 0., 1.) * pixel * f_size);\n        sum += -1. * SHARPENFAST_SAMPLER_FNC(tex, coords + vec2( 1., 0.) * pixel * f_size);\n    }\n    return sum / float(SHARPENFAST_KERNELSIZE);\n}\n#endif\n\n\n\n/*\ncontributors: Patricio Gonzalez Vivo\ndescription: sample an equirect texture as it was a cubemap\nuse: sampleEquirect(<SAMPLER_TYPE> texture, <vec3> dir)\noptions:\n    - SAMPLER_FNC(TEX, UV): optional depending the target version of GLSL (texture2D(...) or texture(...))\n    - SAMPLEEQUIRECT_ITERATIONS: null\n    - SAMPLEEQUIRECT_FLIP_Y\nlicense:\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Prosperity License - https://prosperitylicense.com/versions/3.0.0\n    - Copyright (c) 2021 Patricio Gonzalez Vivo under Patron License - https://lygia.xyz/license\n*/\n\n#ifndef FNC_SAMPLEEQUIRECT\n#define FNC_SAMPLEEQUIRECT\nvec4 sampleEquirect(SAMPLER_TYPE tex, vec3 dir) { \n    vec2 st = xyz2equirect(dir);\n    #ifdef SAMPLEEQUIRECT_FLIP_Y\n    st.y = 1.0-st.y;\n    #endif\n    return SAMPLER_FNC(tex, st); \n}\n\nvec4 sampleEquirect(SAMPLER_TYPE tex, vec3 dir, float lod) { \n    \n    #if defined(SAMPLEEQUIRECT_ITERATIONS)\n    vec4 color = vec4(0.0);\n    vec2 st = xyz2equirect(dir);\n    #ifdef SAMPLEEQUIRECT_FLIP_Y\n        st.y = 1.0-st.y;\n    #endif\n\n    vec2 r = vec2(1.0+lod);\n    const float f = 1.0 / (1.001 - 0.75);\n    mat2 rot = mat2( cos(GOLDEN_ANGLE), sin(GOLDEN_ANGLE), \n                    -sin(GOLDEN_ANGLE), cos(GOLDEN_ANGLE));\n    vec2 st2 = vec2( dot(st + st - r, vec2(.0002,-0.001)), 0.0 );\n\n    float counter = 0.0;\n    #ifdef PLATFORM_WEBGL\n    for (float i = 0.0; i < float(SAMPLEEQUIRECT_ITERATIONS); i++) {\n    #else\n    for (float i = 0.0; i < float(SAMPLEEQUIRECT_ITERATIONS); i += 2.0/i) {\n    #endif\n        st2 *= rot;\n        color += gamma2linear( SAMPLER_FNC(tex, st + st2 * i / vec2(r.x * 2.0, r.y))) * f;\n        counter++;\n    }\n    return linear2gamma(color / counter);\n\n    #else\n\n    dir += srandom3( dir ) * 0.01 * lod;\n    vec2 st = xyz2equirect(dir);\n    #ifdef SAMPLEEQUIRECT_FLIP_Y\n        st.y = 1.0-st.y;\n    #endif\n    return SAMPLER_FNC(tex, st);\n\n    #endif\n}\n\n\n#endif\n\n\n\n/*\ncontributors: [Armin Ronacher, Matt DesLauriers]\ndescription: Basic FXAA implementation based on the code on geeks3d.com with the modification that the texture2DLod stuff was removed since it\'s unsupported by WebGL from https://github.com/mitsuhiko/webgl-meincraft\nuse: sampleFXAA(<SAMPLER_TYPE> tex, <vec2> st, <vec2> pixel)\noptions:\n    - SAMPLER_FNC(TEX, UV): optional depending the target version of GLSL (texture2D(...) or texture(...))\n    - SAMPLEFXAA_REDUCE_MIN\n    - SAMPLEFXAA_REDUCE_MUL\n    - SAMPLEFXAA_SPAN_MAX\n    - SAMPLEFXAA_SAMPLE_FNC\nlicense: \n    - BSD licensed (BSD) Copyright (c) 2011 by Armin Ronacher\n    - MIT License (MIT) Copyright (c) 2014 Matt DesLauriers\n*/\n\n#ifndef SAMPLEFXAA_REDUCE_MIN\n#define SAMPLEFXAA_REDUCE_MIN   (1.0/128.0)\n#endif\n\n#ifndef SAMPLEFXAA_REDUCE_MUL\n#define SAMPLEFXAA_REDUCE_MUL   (1.0/8.0)\n#endif\n\n#ifndef SAMPLEFXAA_SPAN_MAX\n#define SAMPLEFXAA_SPAN_MAX     8.0\n#endif\n\n#ifndef SAMPLEFXAA_SAMPLE_FNC\n#define SAMPLEFXAA_SAMPLE_FNC(TEX, UV) SAMPLER_FNC(TEX, UV)\n#endif\n\n#ifndef FNC_SAMPLEFXAA\n#define FNC_SAMPLEFXAA \nvec4 sampleFXAA(SAMPLER_TYPE tex, vec2 uv, vec2 pixel) {\n    vec3 rgbNW  = SAMPLEFXAA_SAMPLE_FNC(tex,uv.xy + vec2( -1.0, -1.0 ) * pixel).xyz;\n    vec3 rgbNE  = SAMPLEFXAA_SAMPLE_FNC(tex,uv.xy + vec2( 1.0, -1.0 ) * pixel).xyz;\n    vec3 rgbSW  = SAMPLEFXAA_SAMPLE_FNC(tex,uv.xy + vec2( -1.0, 1.0 ) * pixel).xyz;\n    vec3 rgbSE  = SAMPLEFXAA_SAMPLE_FNC(tex,uv.xy + vec2( 1.0, 1.0 ) * pixel).xyz;\n    vec4 rgbaM  = SAMPLEFXAA_SAMPLE_FNC(tex,uv.xy  * pixel);\n    vec3 rgbM   = rgbaM.xyz;\n    vec3 luma   = vec3( 0.299, 0.587, 0.114 );\n    float lumaNW    = dot( rgbNW, luma );\n    float lumaNE    = dot( rgbNE, luma );\n    float lumaSW    = dot( rgbSW, luma );\n    float lumaSE    = dot( rgbSE, luma );\n    float lumaM     = dot( rgbM,  luma );\n    float lumaMin   = min( lumaM, min( min( lumaNW, lumaNE ), min( lumaSW, lumaSE ) ) );\n    float lumaMax   = max( lumaM, max( max( lumaNW, lumaNE) , max( lumaSW, lumaSE ) ) );\n    vec2 dir = vec2(-((lumaNW + lumaNE) - (lumaSW + lumaSE)),\n                     ((lumaNW + lumaSW) - (lumaNE + lumaSE)) );\n\n    float dirReduce = max(  ( lumaNW + lumaNE + lumaSW + lumaSE ) * ( 0.25 * SAMPLEFXAA_REDUCE_MUL ), \n                            SAMPLEFXAA_REDUCE_MIN );\n    float rcpDirMin = 1.0 / ( min( abs( dir.x ), abs( dir.y ) ) + dirReduce );\n    dir = min( vec2(SAMPLEFXAA_SPAN_MAX,  SAMPLEFXAA_SPAN_MAX),\n                max(vec2(-SAMPLEFXAA_SPAN_MAX, -SAMPLEFXAA_SPAN_MAX),\n                    dir * rcpDirMin)) * pixel;\n\n    vec4 rgbA = 0.5 * ( SAMPLEFXAA_SAMPLE_FNC(tex, uv.xy + dir * (1.0/3.0 - 0.5)) +\n                        SAMPLEFXAA_SAMPLE_FNC(tex, uv.xy + dir * (2.0/3.0 - 0.5)) );\n    vec4 rgbB = rgbA * 0.5 + 0.25 * (\n                        SAMPLEFXAA_SAMPLE_FNC(tex, uv.xy + dir * -0.5) +\n                        SAMPLEFXAA_SAMPLE_FNC(tex, uv.xy + dir * 0.5) );\n\n    float lumaB = dot(rgbB, vec4(luma, 0.0));\n    if ( ( lumaB < lumaMin ) || ( lumaB > lumaMax ) )\n        return rgbA;\n    else\n        return rgbB;\n}\n\n#endif\n\n\n\nvec2 worldToSpherical(vec3 flatCoord) {\n    return vec2(\n        atan(flatCoord.z, flatCoord.x) / PI,\n        acos(flatCoord.y) / PI\n    );\n}\n\nfloat stream(vec2 st, vec2 v, float t) {\n    vec2 p = floor(st+v);\n    return 1.0-step(t, random(100.+p*.000001)+random(p.x)*0.5 );\n}\n\nvec3 stream(vec2 uv) {\n    vec3 color = vec3(0.0);\n    \n    vec2 grid = vec2(STREAM_GRID_X, STREAM_GRID_Y);\n    vec2 uv2 = uv * grid;\n    if (STREAM_TYPE < 0.5)\n        uv2 = uv2.yx;\n\n    vec2 ipos = floor(uv2) + 0.1;  // integer\n    vec2 fpos = fract(uv2);  // fraction\n\n    vec2 vel = vec2(u_time * STREAM_SPEED * max(grid.x,grid.y)); // time\n    vel *= vec2(-1.,0.0) * random(1.0+ipos.y); // direction\n\n    vec2 offset = vec2(1.0, 0.0);\n    color.r += stream(uv2 - offset, vel, STREAM_AMOUNT);\n    color.g += stream(uv2, vel, STREAM_AMOUNT);\n    color.b += stream(uv2 + offset, vel, STREAM_AMOUNT);\n    color.rgb *= step(0.2, fpos.y);\n    color = saturate(color);\n\n    color.rgb *= smoothstep(0.0, 1.0, sin(uv.y * PI) );\n    return color;\n}\n\n\nvec3 field(vec2 uv) {\n    vec3 color = vec3(0.0);\n    float time = u_time * FIELD_SPEED;\n    vec2 grid = floor(vec2(FIELD_GRID, FIELD_GRID * 0.5));\n    \n    vec2 uv1 = uv * grid;\n    vec2 uv1_f = fract(uv1);\n    vec2 uv1_i = floor(uv1);\n    \n    // float n = noised( vec3( (uv1_i / grid) * 3.5, time) ).x;\n    float n = noised( vec3( (uv1_i / grid) * 3.5 + time, time * 2.) ).x;\n    // float n = snoise( (uv1_i / grid) * 2.5 + time);\n\n    float nn = n * 0.5 + 0.5;\n\n    vec2 uv2 = uv1_f;\n    uv2 = rotate(uv2, HALF_PI * 0.5);\n    float r2 = rectSDF(uv1_f);\n\n    float l = lengthSq( (uv1_i + 0.5) / grid - 0.5 ) * 4.0;\n    float pct = 1.0;\n    //pct = max(sin(time * PI - l), 0.0);\n\n    float nn_pct = nn * pct;\n    color += fill(r2, .1) * 0.5;\n    color += stroke( uv2.y, 0.5, 0.1) * \n                (nn_pct > 0.25 ? 1.0 : 0.0);\n\n    color += stroke( uv2.x, 0.5, 0.1) *\n                (nn_pct > 0.5 ? 1.0 : 0.0);\n\n    color = saturate(color);\n\n    color *= fill(r2, .5);\n\n    color =  (nn_pct > 0.7 ? vec3(0.9 * rect(uv1_f, 0.9) )  : color );\n\n    color *= smoothstep(-0.75, .75, sin(uv.y * PI)) * 0.5;\n\n    return color;\n}\n\nvec3 enviroment(vec3 normal, float r, float m) {\n    vec3 color = vec3(0.0);\n\n    #ifdef ATMOSPHERE_INTENSITY\n    vec3 atmosphere_normal = normalize(normal + vec3(0.0, ATMOSPHERE_ELEVATION, 0.0));\n    color = atmosphere(atmosphere_normal, normalize(LIGHT_POSITION)) * ATMOSPHERE_INTENSITY;\n    #endif\n\n    #if defined(STREAM_INTENSITY) || defined(FIELD_INTENSITY)\n    vec3 stream_normal = normal;\n\n    #ifdef EQUIRECT_TILT\n    stream_normal = rotate3dX(EQUIRECT_TILT) * stream_normal;\n    #endif\n    \n    #ifdef EQUIRECT_ANGLE\n    stream_normal = rotate3dZ(EQUIRECT_ANGLE) * stream_normal;\n    #endif\n\n    #if defined(FIELD_INTENSITY)\n    color = max(color, stream(worldToSpherical(stream_normal)) * FIELD_INTENSITY);\n    #elif defined(STREAM_INTENSITY) && defined(STREAM_AMOUNT) && defined(STREAM_SPEED) && defined(STREAM_GRID_X) && defined(STREAM_GRID_Y)\n    color = max(color, stream(worldToSpherical(stream_normal)) * STREAM_INTENSITY); \n    #endif\n\n    #endif\n\n    #ifdef GROUND_INTENSITY\n    float flr_pct = dot(normal, vec3(0.0, -1.0, 0.0)) * 0.5 + 0.5;\n    flr_pct *= flr_pct * flr_pct * flr_pct * flr_pct; \n    flr_pct *= max(-normal.y, 0.0);\n    vec3  flr = hue( fract( 0.75 + GROUND_HUE * 0.75 ) );\n    color = max(color, flr * GROUND_INTENSITY * 0.1 * flr_pct );\n    #endif\n\n    return color;\n}\n\n#define ROT_NUM 5\nfloat ang = TAU / float(ROT_NUM);\nmat2 m = mat2( cos(ang), sin(ang),\n                    -sin(ang), cos(ang));\n\nfloat getRot(vec2 pos, vec2 b, vec2 pixel) {\n    vec2 p = b;\n    float rot = 0.0;\n\n    for(int i = 0; i < ROT_NUM; i++) {\n        rot += dot( texture2D(u_doubleBuffer0, (pos + p) * pixel).xy - 0.5, \n                    p.yx * vec2(1.0, -1.0));\n        p = m * p;\n    }\n    return rot / float(ROT_NUM) / dot(b,b);\n}\n\nvec3 lensflares(vec2 uv, vec2 pos) {\n    vec2 main = uv-pos;\n    vec2 uvd = uv*(length(uv));\n\n    float ang = atan(main.y, main.x);\n    float dist = length(main);\n    dist = pow(dist, 0.1);\n\n    vec2 uvx = mix(uv,uvd,-0.5);\n\n    float f4 = max(0.01-pow(length(uvx+0.4*pos),2.4),.0)*6.0;\n    float f42 = max(0.01-pow(length(uvx+0.45*pos),2.4),.0)*5.0;\n    float f43 = max(0.01-pow(length(uvx+0.5*pos),2.4),.0)*3.0;\n\n    uvx = mix(uv,uvd,-0.4);\n\n    float f5 = max(0.01-pow(length(uvx+0.2*pos),5.5),.0)*2.0;\n    float f52 = max(0.01-pow(length(uvx+0.4*pos),5.5),.0)*2.0;\n    float f53 = max(0.01-pow(length(uvx+0.6*pos),5.5),.0)*2.0;\n\n    uvx = mix(uv,uvd,-0.5);\n\n    float f6 = max(0.01-pow(length(uvx-0.3*pos),1.6),.0)*6.0;\n    float f62 = max(0.01-pow(length(uvx-0.325*pos),1.6),.0)*3.0;\n    float f63 = max(0.01-pow(length(uvx-0.35*pos),1.6),.0)*5.0;\n\n    return vec3(f4+f5+f6, f42+f52+f62, f43+f53+f63);\n}\n\n\nvoid main(void) {\n    vec4 color = vec4(0.0, 0.0, 0.0, 1.0);\n    vec2 pos = gl_FragCoord.xy;\n    vec2 pixel = 1.0/u_resolution;\n    vec2 st = pos * pixel;\n    vec2 uv = v_texcoord;\n    float time = TIME_OFFSET + 4.56 + decimate(u_time * 1.1, 10.0);\n    vec2 sst = ratio(st, u_resolution) * 2.0 - 1.0;\n\n    mat3 ca = toMat3(lookAtView(-u_camera, vec3(0.0)));\n    vec3 ray = normalize(ca * vec3(st*2.0-1.0, -1.65));\n\n#if defined(BUFFER_0)\n    vec2 resolution = vec2(512.0, 512.0);\n    pixel = 1.0/resolution;\n\n    float sdf = 1.0-circleSDF(uv);\n    color.rgb = sharpenFast(u_doubleBuffer0, uv, pixel * 10.0 * sdf).rgb;\n\n#elif defined(DOUBLE_BUFFER_0)\n    vec2 resolution = vec2(512.0, 512.0);\n    pixel = 1.0/resolution;\n\n    float rnd = random(u_time);\n    vec2 b = vec2(  cos(ang*rnd), \n                    sin(ang*rnd));\n\n    vec2 scr = uv * 2.0 - 1.0;\n\n    float bbMax = 0.7 * resolution.y; \n    bbMax *= bbMax;\n    \n    vec2 v = vec2(0.0, 0.0);\n    for(int l = 0; l < 20; l++) {\n        if ( dot(b,b) > bbMax ) \n            break;\n        \n        vec2 p = b;\n        for(int i = 0; i < ROT_NUM; i++) {\n            v += p.yx * getRot(pos + p, b, pixel);\n            p = m * p;\n        }\n        b*=2.0;\n    }\n\n    float speed = SIMULATION_SPEED;\n    if (u_frame <= 24) \n        speed = 10.0;\n    \n    color = texture2D(u_doubleBuffer0, (pos + v * vec2(-1.0, 1.0) * speed) * pixel);\n    color.xy += (0.01 * scr.xy / (dot(scr,scr) / 0.1 + 0.3));\n    color.xy = clamp(color.xy, -1.0, 1.0);\n    \n    if (u_frame <= 4) \n        color.xy = noised(vec3(st * 2.0, u_time)).yz;\n\n    color.a = 1.0;\n\n#elif defined(BACKGROUND) \n    color.rgb = ENVMAP_FNC(ray, 1.0, 0.0);\n\n',v="\n\n#else\n\n    #ifdef MODEL_VERTEX_NORMAL\n\n    vec2 v = sampleTriplanar(u_doubleBuffer0, v_normal).xy;\n\n    float thickness = max(v.x, v.y);\n    thickness = thickness * 0.3 + 0.1;\n    thickness = mix(10.0, 700.0, thickness);\n    ray = normalize(v_position.xyz - u_camera);\n    vec3 Fr = vec3(0.0);\n    color.rgb += fresnelIridescentReflection(v_normal, ray, vec3(0.2), vec3(IOR_AIR), vec3(IOR_WATER), thickness, 0.0, Fr);\n    color.rgb += transparent(v_normal, ray, Fr, vec3(1.05, 1.025, 1.0), 0.0);\n    color.rgb += pow(1.0 - max(dot(v_normal, -ray), 0.0), 3.0) * vec3(0.4, 0.5, 0.6) * 3.;\n\n    #endif\n\n#endif\n\n    gl_FragColor = color;\n}";let A="undefined"==typeof tokenData?(()=>{let n="0x";for(let e=64;0<e;--e)n+="0123456789abcdef"[~~(16*Math.random())];return n})():"string"==typeof tokenData?tokenData:tokenData.hash;(()=>{let n=window,e=document,i=e.querySelector("canvas#canvas.emscripten"),t=n.innerWidth,r=n.innerHeight,o=n.devicePixelRatio;i&&(t=427,r=730),(n=>{const e=~~((n.length-2)/2),i=[];for(let t=0;t<e;t++){const e=2+2*t;i.push(parseInt(n.slice(e,e+2),16))}const t=s(i,1690382925),r=s(i,72970470);a.setUint32(0,t),a.setUint32(4,r)})(A);let _="highp",u=E+"\n#elif defined(POSTPROCESSING)\n    color = sampleFXAA(u_scene, st, pixel);\n\n    #ifdef LIGHT_FLARE_INTENSITY\n    vec4 light = vec4(normalize(LIGHT_POSITION), 0.0) * 2.0;\n    vec4 light_ss = u_projectionMatrix * u_viewMatrix * light;\n    light_ss.xy /= light_ss.w;\n    vec3 flare = lensflares(sst, light_ss.xy);\n    flare = (flare * LIGHT_FLARE_INTENSITY);// * step(0.0, light_ss.z);// * max(0.0, light.y);\n    color.rgb += flare;\n    #endif\n\n"+v;(navigator.userAgent.match(/Android/i)||navigator.userAgent.match(/webOS/i)||navigator.userAgent.match(/iPhone/i)||navigator.userAgent.match(/iPad/i)||navigator.userAgent.match(/iPod/i)||navigator.userAgent.match(/BlackBerry/i)||navigator.userAgent.match(/Windows Phone/i))&&(o=1,_="mediump",u=E+v);const p=new THREE.WebGL1Renderer({canvas:i||void 0,precision:_,powerPreference:"high-performance",depth:!1,antialias:!1});p.setPixelRatio(o),p.setSize(t,r),p.autoClearColor=!1,i?(t=427,r=730):e.body.appendChild(p.domElement);const R=new l(p);R.load(u);const S=new THREE.ShaderMaterial({vertexShader:"\nuniform float   u_time;\n\nvarying vec2    v_texcoord;\nvarying vec3    v_normal;\nvarying vec4    v_position;\n\n#ifndef BUBBLE_SHIFT\n#define BUBBLE_SHIFT 0.0\n#endif\n\nvec2 srandom2(vec2 v){const vec2 f=vec2(.3183099,.3678794);v=v*f+f.yx;return-1.+2.*fract(16.*f*fract(v.x*v.y*(v.x+v.y)));}\nvec3 srandom3(vec3 v){v=vec3(dot(v,vec3(127.1,311.7,74.7)),dot(v,vec3(269.5,183.3,246.1)),dot(v,vec3(113.5,271.9,124.6)));return-1.+2.*fract(sin(v)*43758.5453123);}\nvec3 noised(vec2 v){vec2 f=floor(v),x=fract(v),c=x*x*x*(x*(x*6.-15.)+10.),S=srandom2(f+vec2(0)),s=srandom2(f+vec2(1,0)),y=srandom2(f+vec2(0,1)),I=srandom2(f+vec2(1));float A=dot(S,x-vec2(0)),d=dot(s,x-vec2(1,0)),T=dot(y,x-vec2(0,1)),U=dot(I,x-vec2(1));return vec3(A+c.x*(d-A)+c.y*(T-A)+c.x*c.y*(A-d-T+U),S+c.x*(s-S)+c.y*(y-S)+c.x*c.y*(S-s-y+I)+30.*x*x*(x*(x-2.)+1.)*(c.yx*(A-d-T+U)+vec2(d,T)-A));}vec4 noised(vec3 v){vec3 f=floor(v),x=fract(v),c=x*x*x*(x*(x*6.-15.)+10.),S=srandom3(f+vec3(0)),s=srandom3(f+vec3(1,0,0)),y=srandom3(f+vec3(0,1,0)),I=srandom3(f+vec3(1,1,0)),d=srandom3(f+vec3(0,0,1)),T=srandom3(f+vec3(1,0,1)),A=srandom3(f+vec3(0,1,1)),U=srandom3(f+vec3(1));float r=dot(S,x-vec3(0)),z=dot(s,x-vec3(1,0,0)),i=dot(y,x-vec3(0,1,0)),p=dot(I,x-vec3(1,1,0)),u=dot(d,x-vec3(0,0,1)),V=dot(T,x-vec3(1,0,1)),R=dot(A,x-vec3(0,1,1)),Y=dot(U,x-vec3(1));return vec4(r+c.x*(z-r)+c.y*(i-r)+c.z*(u-r)+c.x*c.y*(r-z-i+p)+c.y*c.z*(r-i-u+R)+c.z*c.x*(r-z-u+V)+(-r+z+i-p+u-V-R+Y)*c.x*c.y*c.z,S+c.x*(s-S)+c.y*(y-S)+c.z*(d-S)+c.x*c.y*(S-s-y+I)+c.y*c.z*(S-y-d+A)+c.z*c.x*(S-s-d+T)+(-S+s+y-I+d-T-A+U)*c.x*c.y*c.z+30.*x*x*(x*(x-2.)+1.)*(vec3(z,i,u)-r+c.yzx*vec3(r-z-i+p,r-i-u+R,r-z-u+V)+c.zxy*vec3(r-z-u+V,r-z-i+p,r-i-u+R)+c.yzx*c.zxy*(-r+z+i-p+u-V-R+Y)));}\n\nvoid main(void) {\nv_position = vec4(position, 1.0);\nv_texcoord = uv;\n\nvec4 n = vec4(0.0);\nvec3 p = (v_position.xyz + 100.0) * 0.5;\nn = noised( vec3(p.xy * 0.8, p.z + u_time * 0.2) ) * 0.06;\nv_position.xyz += n.xyz;\nv_position.x += BUBBLE_SHIFT;\nv_position.y -= BUBBLE_ELEVATION;\n\nv_normal = normalize(normal + n.xyz);\n\ngl_Position = projectionMatrix * modelViewMatrix * v_position;\n}\n",fragmentShader:`#define MODEL_VERTEX_NORMAL\n${u}`,uniforms:R.uniforms,defines:R.defines});let T={};for(let n in d.defines)T[n]=2<d.defines[n].length?f(d.defines[n]):c(...d.defines[n]),0==T[n]&&delete T[n];if("filter"in d)for(let n in d.filter){let e=f(d.filter[n]);if(e in T)for(let i in console.log(e,T[e]),T)i!=e&&d.filter[n].includes(i)&&delete T[i]}for(let n in T)R.defines[n]=1==T[n]?T[n].toString():T[n].toFixed(5);const m=new THREE.Mesh(new THREE.SphereGeometry(1,64,32),S),h=new THREE.Scene,L=new THREE.PerspectiveCamera(45,t/r,.001,200);L.position.x=c(-.25,.25),L.position.y=c(-.25,.25),L.position.z=1,console.log(L.position),L.lookAt(0,0,0);let N=c(2.5,5.5);console.log("Distance:",N),L.position.multiplyScalar(N),h.add(m),console.log(S.defines);let M=0;const P=()=>{M=R.clock.getElapsedTime(),R.time+1/24<M&&R.renderScene(h,L),requestAnimationFrame(P)},g=()=>{let a=e.body.classList.contains("windowed-mode");i&&a?(t=427,r=730):(t=n.innerWidth,r=n.innerHeight),o=n.devicePixelRatio,(navigator.userAgent.match(/Android/i)||navigator.userAgent.match(/webOS/i)||navigator.userAgent.match(/iPhone/i)||navigator.userAgent.match(/iPad/i)||navigator.userAgent.match(/iPod/i)||navigator.userAgent.match(/BlackBerry/i)||navigator.userAgent.match(/Windows Phone/i))&&(o=1),p.setPixelRatio(o),p.setSize(t,r),R.setSize(t,r),L.aspect=t/r,L.updateProjectionMatrix()};n.addEventListener("resize",g),g(),P()})();document.addEventListener("DOMContentLoaded",()=>{const n=document.getElementById("resize-btn");if(!n)return;const e=document.getElementById("wrapper");let i=e.classList.contains("fullscreen");n.addEventListener("click",()=>{i=!i,i?(e.classList.add("fullscreen"),e.classList.remove("windowed"),document.body.classList.remove("windowed-mode")):(e.classList.remove("fullscreen"),e.classList.add("windowed"),document.body.classList.add("windowed-mode"))}),new ResizeObserver(()=>{window.dispatchEvent(new Event("resize"))}).observe(e)})}();